<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>dpapp-core</title>
    <meta name="viewport" content="initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    
    <script src="./mocha/mocha.js"></script>
    
    <script>(function(ENV){


/**
 * @preserve Neuron JavaScript Framework (c) Kael Zhang <i@kael.me>
 */

// Goal
// Manage module dependencies and initialization 

// Non-goal
// > What neuron will never do
// 1. Neuron will never care about non-browser environment
// 2. Neuron core will never care about module loading

'use strict';

var neuron = {
  version: '7.2.0'
};

var NULL = null;
var FALSE = !1;

// // Check and make sure the module is downloaded, 
// // if not, it will download the module
// neuron.load = function (module, callback){
//   callback();
// }

// Check and make sure the module is ready for running factory
// By default, 
// neuron core is only a module manager who doesn't care about module loading, 
// and consider all modules are already ready.
// By attaching `load.js` and `ready.js`, neuron will be an loader
neuron.ready = function (module, callback) {
  callback();
};


// ## ECMAScript5 implementation
//////////////////////////////////////////////////////////////////////

// - methods native object implemented
// - methods native object extends

// codes from mootools, MDC or by Kael Zhang

// ## Indexes

// ### Array.prototype
// - indexOf
// - lastIndexOf
// - filter
// - forEach
// - every
// - map
// - some
// - reduce
// - reduceRight

// ### Object
// - keys
// - create: removed

// ### String.prototype
// - trim
// - trimLeft
// - trimRight

// ## Specification

// ### STANDALONE language enhancement

// - always has no dependencies on Neuron
// - always follow ECMA standard strictly, including logic, exception type
// - throw the same error hint as webkit on a certain exception


function extend(host, methods) {
  for (var name in methods) {
    if (!host[name]) {
      host[name] = methods[name];
    }
  }
}


function implement(host, methods) {
  extend(host.prototype, methods);
}


var TYPE_ERROR = TypeError;


// ref: https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array
implement(Array, {

  // Accessor methods ------------------------

  indexOf: function(value, from) {
    var len = this.length >>> 0;

    from = Number(from) || 0;
    from = Math[from < 0 ? 'ceil' : 'floor'](from);

    if (from < 0) {
      from = Math.max(from + len, 0);
    }

    for (; from < len; from++) {
      if (from in this && this[from] === value) {
        return from;
      }
    }

    return -1;
  },

  lastIndexOf: function(value, from) {
    var len = this.length >>> 0;

    from = Number(from) || len - 1;
    from = Math[from < 0 ? 'ceil' : 'floor'](from);

    if (from < 0) {
      from += len;
    }

    from = Math.min(from, len - 1);

    for (; from >= 0; from--) {
      if (from in this && this[from] === value) {
        return from;
      }
    }

    return -1;
  },


  // Iteration methods -----------------------

  filter: function(fn, thisObject) {
    var ret = [];
    for (var i = 0, len = this.length; i < len; i++) {

      // Kael:
      // Some people might ask: "why we use a `i in this` here?".
      // ECMA:
      // > callback is invoked only for indexes of the array which have assigned values; 
      // > it is not invoked for indexes which have been deleted or which have never been assigned values

      // Besides, `filter` method is not always used with real Arrays, invocations below might happen:

      //     var obj = {length: 4}; obj[3] = 1;
      //     Array.prototype.filter.call({length: 4});
      //     Array.prototype.filter.call($('body'));

      // as well as the lines below
      if ((i in this) && fn.call(thisObject, this[i], i, this)) {
        ret.push(this[i]);
      }
    }

    return ret;
  },

  forEach: function(fn, thisObject) {
    for (var i = 0, len = this.length; i < len; i++) {
      if (i in this) {

        // if fn is not callable, it will throw
        fn.call(thisObject, this[i], i, this);
      }
    }
  },

  every: function(fn, thisObject) {
    for (var i = 0, len = this.length; i < len; i++) {
      if ((i in this) && !fn.call(thisObject, this[i], i, this)) {
        return false;
      }
    }
    return true;
  },

  map: function(fn, thisObject) {
    var ret = [],
      i = 0,
      l = this.length;

    for (; i < l; i++) {

      // if the subject of the index i is deleted, index i should not be contained in the result of array.map()
      if (i in this) {
        ret[i] = fn.call(thisObject, this[i], i, this);
      }
    }
    return ret;
  },

  some: function(fn, thisObject) {
    for (var i = 0, l = this.length; i < l; i++) {
      if ((i in this) && fn.call(thisObject, this[i], i, this)) {
        return true;
      }
    }
    return false;
  },

  reduce: function(fn) {
    if (typeof fn !== 'function') {
      throw new TYPE_ERROR(fn + ' is not an function');
    }

    var self = this,
      len = self.length >>> 0,
      i = 0,
      ret;

    if (arguments.length > 1) {
      ret = arguments[1];

    } else {
      do {
        if (i in self) {
          ret = self[i++];
          break;
        }

        // if array contains no values, no initial value to return
        if (++i >= len) {
          throw new TYPE_ERROR('Reduce of empty array with on initial value');
        }
      } while (true);
    }

    for (; i < len; i++) {
      if (i in self) {
        ret = fn.call(NULL, ret, self[i], i, self);
      }
    }

    return ret;
  },

  reduceRight: function(fn) {
    if (typeof fn !== 'function') {
      throw new TYPE_ERROR(fn + ' is not an function');
    }

    var self = this,
      len = self.length >>> 0,
      i = len - 1,
      ret;

    if (arguments.length > 1) {
      ret = arguments[1];

    } else {
      do {
        if (i in self) {
          ret = self[i--];
          break;
        }
        // if array contains no values, no initial value to return
        if (--i < 0) {
          throw new TYPE_ERROR('Reduce of empty array with on initial value');
        }

      } while (true);
    }

    for (; i >= 0; i--) {
      if (i in self) {
        ret = fn.call(NULL, ret, self[i], i, self);
      }
    }

    return ret;
  }

});


extend(Object, {

  // ~ https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/create ~
  // create: function(o){
  //    if(o !== Object(o) && o !== NULL){
  //        throw new TYPE_ERROR('Object prototype may only be an Object or NULL');
  //    }

  //    function F() {}
  //    F.prototype = o;

  //    return new F();
  // },

  // refs:
  // http://ejohn.org/blog/ecmascript-5-objects-and-properties/
  // http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
  // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/keys
  // https://developer.mozilla.org/en/ECMAScript_DontEnum_attribute
  // http://msdn.microsoft.com/en-us/library/adebfyya(v=vs.94).aspx
  keys: (function() {
    var hasOwnProperty = Object.prototype.hasOwnProperty,
      has_dontEnumBug = !{
        toString: ''
      }.propertyIsEnumerable('toString'),

      // In some old browsers, such as OLD IE, keys below might not be able to iterated with `for-in`,
      // even if each of them is one of current object's own properties  
      NONT_ENUMS = [
        'toString',
        'toLocaleString',
        'valueOf',
        'hasOwnProperty',
        'isPrototypeOf',
        'propertyIsEnumerable',
        'constructor'
      ],

      NONT_ENUMS_LENGTH = NONT_ENUMS.length;

    return function(o) {
      if (o !== Object(o)) {
        throw new TYPE_ERROR('Object.keys called on non-object');
      }

      var ret = [],
        name;

      for (name in o) {
        if (hasOwnProperty.call(o, name)) {
          ret.push(name);
        }
      }

      if (has_dontEnumBug) {
        for (var i = 0; i < NONT_ENUMS_LENGTH; i++) {
          if (hasOwnProperty.call(o, NONT_ENUMS[i])) {
            ret.push(NONT_ENUMS[i]);
          }
        }
      }

      return ret;
    };

  })()

  // for our current OOP pattern, we don't reply on Object based inheritance
  // so Neuron has not implemented the methods of Object such as Object.defineProperty, etc.
});


implement(String, {
  trimLeft: function() {
    return this.replace(/^\s+/, '');
  },

  trimRight: function() {
    return this.replace(/\s+$/, '');
  },

  trim: function() {
    return this.trimLeft().trimRight();
  }
});


// common code slice
//////////////////////////////////////////////////////////////////////
// - constants
// - common methods

// @const
// 'a@1.2.3/abc' -> 
// ['a@1.2.3/abc', 'a', '1.2.3', '/abc']

//                    0 1                2         3
var REGEX_PARSE_ID = /^((?:[^\/])+?)(?:@([^\/]+))?(\/.*)?$/;
// On android 2.2,
// `[^\/]+?` will fail to do the lazy match, but `(?:[^\/])+?` works.
// Shit, go to hell!

// Parses a module id into an object

// @param {string} id path-resolved module identifier
// 'a@1.0.0'    -> 'a@1.0.0'
// 'a'          -> 'a@*'
// 'a/inner'    -> 'a@*/inner'
function parse_module_id (id) {
  var match = id.match(REGEX_PARSE_ID);
  var name = match[1];

  // 'a/inner' -> 'a@latest/inner'
  var version = match[2] || '*';
  var path = match[3] || '';

  // There always be matches
  return format_parsed({
    n: name,
    v: version,
    p: path
  });
}


// Format package id and pkg
// `parsed` -> 'a@1.1.0'
function format_parsed(parsed) {
  var pkg = parsed.n + '@' + parsed.v;
  parsed.id = pkg + parsed.p;
  parsed.k = pkg;
  return parsed;
}


// Legacy
// Old neuron modules will not define a real resolved id.
// We determine the new version by `env.map`
// Since 6.2.0, actually, neuron will and should no longer add file extension arbitrarily,
// because `commonjs-walker@3.x` will do the require resolve during parsing stage.
// But old version of neuron did and will add a `config.ext` to the end of the file.
// So, if commonjs-walker does so, we adds a 
function legacy_transform_id (id, env) {
  return env.map
    ? id
    : id + '.js';
}


// A very simple `mix` method
// copy all properties in the supplier to the receiver
// @param {Object} receiver
// @param {Object} supplier
// @returns {mixed} receiver
function mix(receiver, supplier) {
  for (var c in supplier) {
    receiver[c] = supplier[c];
  }
}


// greedy match:
var REGEX_DIR_MATCHER = /.*(?=\/.*$)/;

// Get the current directory from the location
//
// http://jsperf.com/regex-vs-split/2
// vs: http://jsperf.com/regex-vs-split
function dirname(uri) {
  var m = uri.match(REGEX_DIR_MATCHER);

  // abc/def  -> abc
  // abc      -> abc  // which is different with `path.dirname` of node.js
  // abc/     -> abc
  return m ? m[0] : uri;
}


// Get the relative path to the root of the env
// @returns {string} a module path
function resolve_path (path, env) {
  // '', 'a.png' -> 'a.png'
  // '', './a.png' -> 'a.png'
  // '', '../a.png' -> '../a.png'
  // '/index.js', 'a.png' -> 'a.png'
  return path_join(
    // '' -> '' -> ''
    // '/index.js' -> '/' -> ''
    dirname(env.p).slice(1),
    path
  );
}


// Resolves an id according to env
// @returns {string} a module id
function resolve_id (path, env) {
  path = resolve_path(path, env);
  return path
    ? env.k + '/' + path
    : env.k;
}


// Canonicalize path
// The same as `path.resolve()` of node.js.

// For example:
// path_join('a', 'b')        -> 'a/b'
// path_join('a/b', './c')    -> 'a/b/c'
// path_join('a/b', '../c')   -> 'a/c'
// path_join('a//b', './c')   -> 'a/b/c'

// #75:
// path_join('../abc', './c') -> '../abc/c',

// path_join('', './c')       -> 'c'
// path_join('', '../c')      -> '../c' 
function path_join(from, to) {
  var parts = (from + '/' + to)
    .split('/')
    // Filter empty string:
    // ['', '.', 'c'] -> ['.', 'c']
    .filter(Boolean);
  return normalize_array(parts).join('/');
}


// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalize_array(parts) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  var i = parts.length - 1;
  for (; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);

    } else if (last === '..') {
      parts.splice(i, 1);
      up++;

    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  while (up--) {
    parts.unshift('..');
  }

  return parts;
}


// @param {string} path
function is_path_relative(path) {
  return path.indexOf('./') === 0 || path.indexOf('../') === 0;
}


// var REGEX_LEADING_SLASH = /^\//;
// function removes_leading_slash (str) {
//   return str.replace(REGEX_LEADING_SLASH, '');
// }


function err (message) {
  throw new Error('neuron: ' + message);
}


function module_not_found (id) {
  err("Cannot find module '" + id + "'");
}


// ## A very simple EventEmitter
//////////////////////////////////////////////////////////////////////

var events = {};

// @param {this} self
// @param {string} type
// @returns {Array.<function()>}
function get_event_storage_by_type(type) {
  return events[type] || (events[type] = []);
}


// Register an event once
function on(type, fn) {
  get_event_storage_by_type(type).push(fn);
}


// Emits an event
function emit(type, data) {
  var handlers = get_event_storage_by_type(type);
  handlers.forEach(function(handler) {
    handler(data);
  });
}


neuron.on = on;


// ## Neuron Core: Module Manager
//////////////////////////////////////////////////////////////////////

// ## CommonJS
// Neuron 3.x or newer is not the implementation of any CommonJs proposals
// but only [module/1.0](http://wiki.commonjs.org/wiki/Modules/1.0), one of the stable CommonJs standards.
// And by using neuron and [cortex](http://github.com/cortexjs/cortex), user could write module/1.0 modules.
// Just FORGET `define`.

// ## Naming Conventions of Variables
// All naming of variables should accord to this.

// Take `'a@1.0.0/relative'` for example:

// ### package 
// The package which the current module belongs to.
// - name or package name:  {string} package `name`: 'a'
// - package or package id: {string} contains package `name` and `version` and the splitter `'@'`. 
//   'a@1.0.0' for instance.

// ### module
// A package is consist of several module objects.
// - mod: {object} the module object. use `mod` instead of `module` to avoid confliction
// - id or module id: the descripter that contains package name, version, and path information
//      {string} for example, `'a@1.0.0/relative'` is a module id(entifier)

// ### version
// Package version: '1.0.0'

// ### main entry
// The module of a package that designed to be accessed from the outside

// ### shadow module and module
// A single module may have different contexts and runtime results
// - mod: the original module definition, including factory function, dependencies and so on
// - module: the shadow module, which is inherited from `mod`

////////////////////////////////////////////////////////////////////////////////////////////////


// Parse an id within an environment, and do range mapping, resolving, applying aliases.
// Returns {Object} parsed object
// @param {string} id
// @param {Object=} env the environment module
function parse_id(id, env) {
  // commonjs parser could not parse non-literal argument of `require`
  id || err('null id');

  env || (env = {});
  // {
  //   alias: {
  //     // id -> path
  //     './a' -> './a.js'
  //   }
  // }
  var map = env.map || {};
  id = map[id] || id;

  // Two kinds of id:
  // - relative module path
  // - package name
  // - a module with path loaded by facade or _use
  var parsed;
  var relative = is_path_relative(id);

  // `env` exists, which means the module is accessed by requiring within another module.
  // `id` is something like '../abc'
  if (relative) {
    env.id || module_not_found(id);

    id = resolve_id(id, env);

    // Legacy
    // If >= 6.2.0, there is always a map,
    // and a value of map is always a top level module id.
    // So, only if it is old wrappings, it would come here.
    // Besides, if not a relative id, we should not adds `'.js'` even it is an old wrapping.
    // How ever, we pass `env` to have a double check.
    id = legacy_transform_id(id, env);

    parsed = parse_module_id(id);

  // `id` is something like 'jquery'
  } else {
    // 1. id is a package name
    // 'jquery' -> 'jquery@~1.9.3'
    // 2. id may be is a package id
    // 'jquery@^1.9.3' -> 'jquery@^1.9.3'
    id = env.m && env.m[id] || id;
    // 'jquery' -> {n: 'jquery', v: '*', p: ''}
    // 'jquery@~1.9.3' -> {n: 'jquery', v: '~1.9.3', p: ''}
    parsed = parse_module_id(id);
  }

  
  if (parsed.k === env.k) {
    // if inside the same package of the parent module,
    // it uses a same sub graph of the package
    parsed.graph = env.graph;

  } else {
    // We route a package of certain range to a specific version according to `config.graph`
    // so several modules may point to a same exports
    // if is foreign module, we should parses the graph to the the sub graph
    var sub_graph = get_sub_graph(parsed.k, env.graph) 
      // If sub_graph not found, set it as `[]`
      || [];
    parsed.graph = sub_graph;
    parsed.v = sub_graph[0] || parsed.v;
    format_parsed(parsed);
  }

  return parsed;
}


function get_sub_graph (pkg, graph) {
  var global_graph = NEURON_CONF.graph._;
  var deps = graph
    ? graph[1]
    // If `graph` is undefined, fallback to global_graph
    : global_graph;
  return deps && (pkg in deps)
    // `deps[pkg]` is the graph id for the subtle graph
    ? NEURON_CONF.graph[deps[pkg]]
    : global_graph;
}


// Get the exports
// @param {Object} module
function get_exports(module) {
  // Since 6.0.0, neuron will not emit a "cyclic" event.
  // But, detecing static cyclic dependencies is a piece of cake for compilers, 
  // such as [cortex](http://github.com/cortexjs/cortex)
  return module.loaded
    ? module.exports

    // #82: since 4.5.0, a module only initialize factory functions when `require()`d.
    : generate_exports(module);
}


// Generate the exports of the module
function generate_exports (module) {
  // # 85
  // Before module factory being invoked, mark the module as `loaded`
  // so we will not execute the factory function again.
  
  // `mod.loaded` indicates that a module has already been `require()`d
  // When there are cyclic dependencies, neuron will not fail.
  module.loaded = true;

  // During the execution of factory, 
  // the reference of `module.exports` might be changed.
  // But we still set the `module.exports` as `{}`, 
  // because the module might be `require()`d during the execution of factory 
  // if cyclic dependency occurs.
  var exports = module.exports = {};

  // TODO:
  // Calculate `filename` ahead of time
  var __filename
    // = module.filename 
    = module_id_to_absolute_url(module.id);
  var __dirname = dirname(__filename);

  // to keep the object mod away from the executing context of factory,
  // use `factory` instead `mod.factory`,
  // preventing user from fetching runtime data by 'this'
  var factory = module.factory;
  factory(create_require(module), exports, module, __filename, __dirname);
  return module.exports;
}


var guid = 1;

// Get a shadow module or create a new one if not exists
// facade({ entry: 'a' })
function get_module (id, env, strict) {
  var parsed = parse_id(id, env);
  var graph = parsed.graph;
  var mod = get_mod(parsed);

  var real_id = mod.main
    // if is main module, then use `pkg` as `real_id`
    ? parsed.k
    : parsed.id;

  // `graph` is the list of modules for a certain package
  var module = graph[real_id];

  if (!module) {
    !strict || module_not_found(id);
    // So that `module` could be linked with a unique graph
    module = graph[real_id] = create_shadow_module(mod);
    module.graph = graph;

    // guid
    module.g || (module.g = guid ++);
  }

  return module;
}


// @param {Object} module
// @param {function(exports)} callback
function use_module (module, callback) {
  neuron.ready(module, function () {
    callback(get_exports(module));
  });
}


// Create a mod
function get_mod(parsed) {
  var id = parsed.id;
  return mods[id] || (mods[id] = {
    // package name: 'a'
    n: parsed.n,
    // package version: '1.1.0'
    v: parsed.v,
    // module path: '/b'
    p: parsed.p,
    // module id: 'a@1.1.0/b'
    id: id,
    // package id: 'a@1.1.0'
    k: parsed.k,
    // version map of the current module
    m: {},
    // loading queue
    l: [],
    // If no path, it must be a main entry.
    // Actually, it actually won't happen when defining a module
    main: !parsed.p
    // map: {Object} The map of aliases to real module id
  });
}


// @param {Object} mod Defined data of mod
function create_shadow_module (mod) {
  function F () {
    // callbacks
    this.r = [];
  }
  F.prototype = mod;
  return new F;
}


// Since 4.2.0, neuron would not allow to require an id with version
// TODO:
// for scoped packages
function test_require_id (id) {
  !~id.indexOf('@') || err("id with '@' is prohibited");
}


// use the sandbox to specify the environment for every id that required in the current module 
// @param {Object} env The object of the current module.
// @return {function}
function create_require(env) {
  var require = function(id) {
    // `require('a@0.0.0')` is prohibited.
    test_require_id(id);

    var module = get_module(id, env, true);
    return get_exports(module);
  };

  // @param {string} id Module identifier. 
  // Since 4.2.0, we only allow to asynchronously load a single module
  require.async = function(id, callback) {
    var origin = id;
    if (callback) {
      // `require.async('a@0.0.0')` is prohibited
      test_require_id(id);
      var relative = is_path_relative(id);
      if (relative) {
        id = resolve_id(id, env);
        var entries = env.entries;
        id = entries
          ? test_entries(id, entries) 
            || test_entries(id + '.js', entries) 
            || test_entries(id + '.json', entries)
            || module_not_found(origin)
          : legacy_transform_id(id, env);
      }

      var module = get_module(id, env);
      if (!module.main) {
        if (relative) {
          // If user try to load a non-entry module, it will get a 404 response
          module.a = true;
        } else {
          // We only allow to `require.async` main module or entries of the current package 
          return;
        }
      }

      use_module(module, callback);
    }
  };

  // @param {string} path
  // @returns
  // - {string} if valid
  // - otherwise `undefined`
  require.resolve = function (path) {
    // NO, you should not do this:
    // `require.resolve('jquery')`
    // We only allow to resolve a relative path

    // Trying to load the resources of a foreign package is evil.
    if (is_path_relative(path)) {
      path = resolve_path(path, env);

      // If user try to resolve a url outside the current package
      // it fails silently
      if (!~path.indexOf('../')) {
        var md5 = get_md5(env.k, path);
        path = append_md5_to_path(path, md5);
        return module_id_to_absolute_url(env.k + '/' + path);
      }
    }
  };

  return require;
}


function test_entries (path, entries) {
  return ~entries.indexOf(path)
    ? path
    : FALSE;
}


// ## Script Loader
//////////////////////////////////////////////////////////////////////

var DOC = document;

// never use `document.body` which might be NULL during downloading of the document.
var HEAD = DOC.getElementsByTagName('head')[0];

function load_js(src) {
  var node = DOC.createElement('script');

  node.src = src;
  node.async = true;

  js_onload(node, function() {
    HEAD.removeChild(node);
  });

  // A very tricky way to avoid several problems in iOS webviews, including:
  // - webpage could not scroll down in iOS6
  // - could not maintain vertial offset when history goes back.
  setTimeout(function () {
    HEAD.insertBefore(node, HEAD.firstChild);
  }, 0);
}


var js_onload = DOC.createElement('script').readyState
  // @param {DOMElement} node
  // @param {!function()} callback asset.js makes sure callback is not NULL
  ? function(node, callback) {
    node.onreadystatechange = function() {
      var rs = node.readyState;
      if (rs === 'loaded' || rs === 'complete') {
        node.onreadystatechange = NULL;
        callback.call(this);
      }
    };
  }

  : function(node, callback) {
    node.addEventListener('load', callback, false);
  };
  

// module define
// ---------------------------------------------------------------------------------------------------


// Method to define a module.

// **NOTICE** that `define` has no fault tolerance and type checking since neuron 2.0,
// because `define` method is no longer designed for human developers to use directly.
// `define` should be generated by some develop environment such as [cortex](http://github.com/cortexjs/cortex)
// @private

// @param {string} id (optional) module identifier
// @param {Array.<string>} dependencies ATTENSION! `dependencies` must be array of standard 
//   module id and there will be NO fault tolerance for argument `dependencies`. Be carefull!
// @param {function(...[*])} factory (require, exports, module)
// @param {Object=} options

// @return {undefined}
function define(id, dependencies, factory, options) {
  (options) || (options = {});

  var parsed = parse_id(id);
  if (parsed.p) {
    // Legacy
    // in old times, main entry: 
    // - define(id_without_ext)
    // - define(pkg) <- even older
    // now, main entry: define(id_with_ext)
    parsed.p = legacy_transform_id(parsed.p, options);
    format_parsed(parsed);
  }
  
  var pkg = parsed.k;
  var modMain;
  if (options.main) {
    modMain = mods[pkg];
  }

  // `mod['a@1.1.0']` must be USED before `mod['a@1.1.0/index.js']`,
  // because nobody knows which module is the main entry of 'a@1.1.0'
  // But `mod['a@1.1.0/index.js']` might be DEFINED first.
  var mod = mods[parsed.id] = modMain || mods[parsed.id] || get_mod(parsed);
  if (options.main) {
    mods[pkg] = mod;
    // Set the real id and path
    mix(mod, parsed);
  }
  mix(mod, options);

  // A single module might be defined more than once.
  // use this trick to prevent module redefining, avoiding the subsequent side effect.
  // mod.factory        -> already defined
  // X mod.exports  -> the module initialization is done
  if (!mod.factory) {
    mod.factory = factory;
    mod.deps = dependencies;
    // ['a@0.0.1']  -> {'a' -> 'a@0.0.1'}
    generate_module_version_map(dependencies, mod.m);

    var asyncDeps = options.asyncDeps;
    if (asyncDeps) {
      generate_module_version_map(asyncDeps, mod.m);
    }

    run_callbacks(mod, 'l');
  }
}


// @private
// create version info of the dependencies of current module into current sandbox
// @param {Array.<string>} modules no type detecting
// @param {Object} host

// ['a@~0.1.0', 'b@~2.3.9']
// -> 
// {
//     a: '~0.1.0',
//     b: '~2.3.9'
// }
function generate_module_version_map(modules, host) {
  modules.forEach(function(mod) {
    var name = mod.split('@')[0];
    host[name] = mod;
  });
}


// Run the callbacks
function run_callbacks (object, key) {
  var callbacks = object[key];
  var callback;
  // Mark the module is ready
  // `delete module.c` is not safe
  // #135
  // Android 2.2 might treat `null` as [object Global] and equal it to true,
  // So, never confuse `null` and `false`
  object[key] = FALSE;
  while(callback = callbacks.pop()){
    callback();
  }
}


// The logic to load the javascript file of a package
//////////////////////////////////////////////////////////////////////


function load_module (module, callback) {
  var mod = mods[module.id];
  mod.f = module.f;
  mod.a = module.a;
  var callbacks = mod.l;
  if (callbacks) {
    callbacks.push(callback);
    if (callbacks.length < 2) {
      load_by_module(mod);
    }
  }
}


// Scenarios:
// 1. facade('a/path');
// -> load a/path -> always
// 2. facade('a');
// -> load a.main
// 3. require('a');
// -> deps on a
// 4. require('./path')
// -> deps on a
// 5. require.async('a')
// -> load a.main ->
// 6. require.async('./path')
// -> load a/path
// 7. require.async('b/path'): the entry of a foreign module
// -> forbidden

var pkgs = [];

// Load the script file of a module into the current document
// @param {string} id module identifier
function load_by_module(mod) {
  if (mod.d) {
    return;
  }

  // (D)ownloaded
  // flag to mark the status that a module has already been downloaded
  mod.d = true;

  var isFacade = mod.f;
  var isAsync = mod.a;
  var pkg = mod.k;

  // if one of the current package's entries has already been loaded,
  // and if the current module is not an entry(facade or async)
  if (~pkgs.indexOf(pkg)) {
    if (!isFacade && !isAsync) {
      return;
    }
  } else {
    pkgs.push(pkg);
  }

  var loaded = NEURON_CONF.loaded;
  // is facade ?
  var evidence = isFacade
    // if a facade is loaded, we will push `mod.id` of the facade instead of package id
    // into `loaded`
    ? mod.id
    : pkg;

  if (~loaded.indexOf(evidence)) {
    if (!isAsync) {
      // If the main entrance of the package is already loaded
      // and the current module is not an async module, skip loading.
      // see: declaration of `require.async`
      return;
    }

    // load packages
  } else {
    loaded.push(evidence);
  }

  load_js(module_to_absolute_url(mod));
}

function append_md5_to_path(path, md5){
  var ext = path.match(/\.[\w\d]+$/)[0];
  if(md5){
    return path.replace(new RegExp(ext + "$"), "_" + md5 + ext);
  }else{
    return path;
  }
}

function module_to_absolute_url(mod) {
  var md5 = get_md5(mod.k, mod.main ? (mod.n + ".js") : mod.p.slice(1));
  var id = mod.main
    // if is a main module, we will load the source file by package

    // 1.
    // on use: 'a@1.0.0' (async or sync)
    // -> 'a/1.0.0/a.js'

    // 2.
    // on use: 'a@1.0.0/relative' (sync)
    // -> not an async module, so the module is already packaged inside:
    // -> 'a/1.0.0/a.js'
    ? mod.k + '/' + mod.n + '.js'

    // if is an async module, we will load the source file by module id
    : mod.id;

  var origin_url = module_id_to_absolute_url(id);

  return append_md5_to_path(origin_url, md5);
}

function get_md5(package_id, mod_path){
  return NEURON_CONF.hash && NEURON_CONF.hash[package_id] && NEURON_CONF.hash[package_id][mod_path];
}


// server: 'http://localhost/abc',
// -> http://localhost/abc/<relative>
// @param {string} relative relative module url
function module_id_to_absolute_url(id) {
  var pathname = id.replace('@', '/');
  var base = NEURON_CONF.path;
  base || err('config.path must be specified');
  base = base.replace('{n}', pathname.length % 3 + 1);

  return base + pathname;
}


// ## Graph Isomorphism and Dependency resolving
//////////////////////////////////////////////////////////////////////

// ### module.defined <==> module.factory
// Indicates that a module is defined, but its dependencies might not defined. 

// ### module.ready
// Indicates that a module is ready to be `require()`d which may occurs in two cases
// - A module is defined but has no dependencies
// - A module is defined, and its dependencies are defined, ready or loaded

// ### module.loaded
// Indicates that module.exports has already been generated

// Register the ready callback for a module, and recursively prepares
// @param {Object} module
// @param {function()} callback
// @param {Array=} stack
function ready (module, callback, stack) {
  emit('beforeready', module_id(module) + ':' + module.g);

  if (!module.factory) {
    emit('beforeload', module.id);
    return load_module(module, function () {
      emit('load', module_id(module));
      ready(module, callback, stack);
    });
  }

  var deps = module.deps;
  var counter = deps.length;

  var callbacks = module.r;
  // `module.r` is `[]` in origin.
  // `!callbacks` means the module is ready
  if (!counter || !callbacks) {
    module.r = FALSE;
    emit_ready(module);
    return callback();
  }

  callbacks.push(callback);
  // if already registered, skip checking
  if (callbacks.length > 1) {
    return;
  }

  var cb = function () {
    if (!-- counter) {
      stack.length = 0;
      stack = NULL;
      emit_ready(module);
      run_callbacks(module, 'r');
    }
  };

  stack = stack
    ? [module].concat(stack)
    : [module];

  deps.forEach(function (dep) {
    var child = get_module(dep, module);
    // If the child is already in the stack,
    // which means there might be cyclic dependency, skip it.
    if (~stack.indexOf(child)) {
      return cb();
    }
    ready(child, cb, stack);
  });
}


function emit_ready (module) {
  emit('ready', module_id(module) + ':' + module.g);
}


function module_id (module) {
  return module.main ? module.k : module.id;
}

// @override
neuron.ready = ready;



// Manage configurations
//////////////////////////////////////////////////////////////////////

// var neuron_loaded = [];
var NEURON_CONF = neuron.conf = {
  loaded: [],
  // If `config.tree` is not specified,
  graph: {
    _: {}
  }
};


var SETTERS = {

  // The server where loader will fetch modules from
  // if use `'localhost'` as `base`, switch on debug mode
  'path': function(path) {
    // Make sure
    // - there's one and only one slash at the end
    // - `conf.path` is a directory
    return path.replace(/\/*$/, '/');
  },
  'hash': justReturn,
  'loaded': justReturn,
  'graph': justReturn
};


function justReturn(subject) {
  return subject;
}


function config(conf) {
  var key;
  var setter;
  for (key in conf) {
    setter = SETTERS[key];
    if (setter) {
      NEURON_CONF[key] = setter(conf[key]);
    }
  }
}

neuron.config = config;


// ## Explode public methods
//////////////////////////////////////////////////////////////////////

ENV.neuron = neuron;

// @expose
ENV.define = define;

// @expose
// Attach a module for business facade, for configurations of inline scripts
// if you want a certain biz module to be initialized automatically, the module's exports should contain a method named 'init'
// ### Usage 
// ```
// // require biz modules with configs
// facade({
//   entry: 'app-main-header-bar',
//   data: {
//     icon: 'http://kael.me/u/2012-03/icon.png'
//   }
// });
//  ```
ENV.facade = function (item) {
  use_module_by_id(item.entry, function(method) {
    method.init && method.init(item.data);
  });
};


// private methods only for testing
// avoid using this method in product environment
// @expose
ENV._use = function (id, callback) {
  use_module_by_id(id, callback);
};

// @expose
ENV._load = load_js;


function use_module_by_id (id, callback) {
  var module = get_module(id);
  module.f = true;
  use_module(module, callback);
}



// map of id -> defined module data
var mods = neuron.mods = {};



// Use `this`, and never cares about the environment.
})(this);</script>
    <script>
        var global = window;
        neuron.config({
            path: "http://s2.51ping.com/mod",
            graph: {"0":["1.1.0",{"mix@^1.0.1":1,"promise@^6.1.0":2,"assert@*":4}],"1":["1.0.1"],"2":["6.1.0",{"asap@^1.0.0":3}],"3":["1.0.0"],"4":["1.0.1",{"util@~1.0.0":5,"json@~1.0.1":6}],"5":["1.0.5",{"json@~1.0.0":6}],"6":["1.0.1"],"_":{"dpapp-core@1.1.0":0}},
            loaded:["dpapp-core@1.1.0"]
        });
    </script>
    
    <link rel="stylesheet" href="./mocha/mocha.css">
    
</head>
<body>
    <style type="text/css">
.reload{
    position:fixed;
    right:10px;
    bottom:10px;
    box-shadow:0 0 3px rgba(0,0,0,0.6);
    border-radius: 20px;
    line-height: 20px;
    padding: 10px;
    height: 20px;
    width: 20px;
    text-align: center;
}
.btn{
	display: block;
	background-color: #6a3;
	color:#fff;
	text-decoration: none;
	text-align: center;
	font-size: 16px;
	padding: 10px 5px;
	margin: 10px 5px;
	border-radius: 5px;
	font-family: sans-serif;
}
.btn.disabled{
	background-color: #ccc;
}
</style>
<script>
    window.onerror = function(err){
        console.error(err);
    }
</script>
<div class="appear-count">appear-count: <span class="count">0</span></div>
<div class="disappear-count">disappear-count: <span class="count">0</span></div>
<div class="performance-timing">has performance.timing: <span class="value"></span></div>
<div class="document-event">has document event: <span class="value"></span></div>
<a class="btn reload"  href="javascript:location.reload()">R</a>
<div id="uiTests" style="margin-top:60px"></div>
    <div id="mocha"></div>
    <script>

    mocha.NO_CATCH_EXCEPTIONS = true;
    !window.PHANTOMJS && mocha.setup("bdd");
    (function(){
function mix(a,b){for(var k in b){a[k]=b[k];}return a;}
var _0 = "assert@*";
var _1 = "dpapp-core@1.1.0/lib/index.js";
var _2 = "dpapp-core@1.1.0/lib/network.js";
var _3 = "promise@^6.1.0";
var _4 = "dpapp-core@1.1.0/lib/core.js";
var _5 = "dpapp-core@1.1.0/lib/native-core.js";
var _6 = "dpapp-core@1.1.0/lib/apis.js";
var _7 = "dpapp-core@1.1.0/lib/decorate.js";
var _8 = "dpapp-core@1.1.0/lib/queue.js";
var _9 = "dpapp-core@1.1.0/test/dpapp-core.js";
var asyncDepsToMix = {};
var globalMap = asyncDepsToMix;
define(_9, [_0,_1,_2], function(require, exports, module, __filename, __dirname) {
'use strict';
var Core = require('../lib/index');
var network = require('../lib/network');
var assert = require('assert');
var isApp = navigator.userAgent.match(/dp\//);

window.DPApp = new Core();

function setReadyState(){
    document.querySelector('.document-event').innerHTML = !!window.performance.timing;
}
document.addEventListener('DPJSBridgeReady', function(){
  setReadyState();
});

if(document.dpReadyState){
  setReadyState();
}

window.addEventListener('load', function(){
  document.querySelector('.performance-timing .value').innerHTML = !!window.performance.timing;
});

var uiTests = {
  closeWindow: {},
  openScheme:{
    url: "titans://web/",
    extra: {
      "url": "http://127.0.0.1:1976/page2.html"
    }
  },
  sendSMS: {
    recipients: 13987654321,
    content: "短信内容"
  },
  alert: {
    title: '来自xxx页面（默认为空）',
    message: '领取红包成功',
    button: '好的',
    success: function(){
      alert('弹出窗已关闭');
    }
  },
  confirm: {
    title: '来自xxx页面（默认为空）',
    message: '真的要做这个操作么',
    okButton: '做做做',
    cancelButton: '容朕再想想',
    success: function(e){
      if(e.ret == true){
        alert('刚刚点击了确认');
      }else{
        alert('刚刚点击了取消');
      }
    }
  },
  appear: [{
    name: "onAppear",
    api: "subscribe",
    config: {
      action: "appear",
      success: function(){
        console.log('注册appear成功');
      },
      handle: function(e){
        console.log('appear triggered');
        document.querySelector('.appear-count .count').innerHTML = +document.querySelector('.appear-count .count').innerHTML + 1;
      }
    }
  }, {
    name: "offAppear",
    api: "unsubscribe",
    config: {
      action: "appear",
      success: function(){
        console.log('取消注册appear成功');
      }
    }
  }],
  disappear: [{
    name: "onDisappear",
    api: "subscribe",
    config: {
      action: "disappear",
      success: function(){
        console.log('注册disappear成功');
      },
      handle: function(e){
        console.log('disappear triggered');
        document.querySelector('.disappear-count .count').innerHTML = +document.querySelector('.disappear-count .count').innerHTML + 1;
      }
    }
  }, {
    name: "offDisappear",
    api: "unsubscribe",
    config: {
      action: "disappear",
      success: function(){
        console.log('取消注册disappear成功');
      }
    }
  }],
  prompt: {
    title: '来自xxx页面（默认为空）',
    message: '你有什么想说的',
    placeholder: '请讲中文喔',
    okButton: '就这些',
    cancelButton: '木有',
    success: function(e){
      var text = e.text;
      if(e.ret == true){
        alert('刚刚输入了' + text);
      }else{
        alert('刚刚点击了取消');
      }
    }
  },
  actionSheet: {
    title: '请选择角色',
    selections: [
      '王大锤',
      '张全蛋',
      '马建国'
    ],
    cancelButton: '还是算了',
    success: function(e){
      var canceled = e.selectedIndex == 3;
      if(canceled){
        alert('刚刚点击了取消');
      }else{
        alert('刚刚选择了第' + e.selectedIndex + '项');
      }
    }
  },
  setTitle: {
    title: '标题',
    subtitle: '副标题',
    success: function(){
      alert('设置成功')
    }
  },
  setSegmentTitle: {
    segment: [{
      title: 'A'
    },{
      title: 'B',
      selected: true
    },{
      title: 'C'
    }],
    type: 'segment',
    handle: function(e){
      alert('选择了:' + e.selected);
    }
  }
}

var uiTestContainer = document.getElementById('uiTests');

function createButton(name, api, config){
  var elem = document.createElement('div');
  elem.setAttribute('class','btn');
  elem.innerHTML = name;
  uiTestContainer.appendChild(elem);
  elem.addEventListener('click', function(){
    DPApp[api](config);
  });

  if(!DPApp.isSupport(api)){
    elem.classList.add('disabled');
  }
}
Object.keys(uiTests).forEach(function(name){
  if(uiTests[name].constructor == Array){
    uiTests[name].forEach(function(item){
      createButton(item.name, item.api, item.config);
    });
  }else{
    createButton(name, name, uiTests[name]);
  }
});

DPApp.patchForType("web", {
  ready: function(callback){
    callback();
  }
});

describe("Network", function(){

  it("osUA", function(){
    var osUA = Core.prototype._parseUA("ZTE U930_TD/1.0 Linux/2.6.39 Android/4.0 Release/3.5.2012 Browser/AppleWebKit534.30 dp/com.dianping.v1/7.6.0");
    assert.deepEqual(osUA, {
      name:"android",
      version:"4.0"
    });

    var osUA = Core.prototype._parseUA("Mozilla/5.0 (Linux; Android 5.1; HTC D728d Build/LMY47D; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/42.0.2311.137 Mobile Safari/537.36 dp/com.dianping.v1/7.1.1ctch1");
    assert.deepEqual(osUA, {
      name:"android",
      version:"5.1"
    });
  });

  it("ios should be ok", function(){
    // your code...
    assert.equal(network._iOSNetworkType({
      type: "0",
      subType: ""
    }),"none");

    assert.equal(network._iOSNetworkType({
      type: "85538",
      subType: ""
    }),"wifi");

    assert.equal(network._iOSNetworkType({
      type: "327683",
      subType: "CTRadioAccessTechnologyEdge"
    }),"2g");

    assert.equal(network._iOSNetworkType({
      type: "327683",
      subType: "CTRadioAccessTechnologyHSDPA"
    }),"3g");

    assert.equal(network._iOSNetworkType({
      type: "327683",
      subType: "CTRadioAccessTechnologyLTE"
    }),"4g");
  });


  it("android should be ok", function(){

    assert.equal(network._androidNetworkType({
    }),"none");

    assert.equal(network._androidNetworkType({
      type: 1,
      subType: 0
    }),"wifi");

    assert.equal(network._androidNetworkType({
      type: 0,
      subType: 4
    }),"2g");

    assert.equal(network._androidNetworkType({
      type: 0,
      subType: 8
    }),"3g");

    assert.equal(network._androidNetworkType({
      type: 0,
      subType: 13
    }),"4g");
  });
});

describe("Semver", function(){
  it("semver", function(){
    var semver = DPApp.Semver;
    assert(semver.gt("7.1.0","7.0.0"));
    assert(semver.gt("7.1.0","7.0"));
    assert(semver.gt("7.1.0","7"));
    assert(semver.gte("7.1.0","7.1.0"));
  });
});

describe("Common", function(){
  it("ready", function(done){
    DPApp.ready(done);
  });

  it("translateModel", function(done){
    var result = DPApp._transModel(["Count","Code"], {
      "0x222d":502,
      "0x630b":0
    });
    assert.equal(result.Code,502);
    assert.equal(result.Count,0);
    done();
  });
});


if(!isApp){

describe("Web", function(){
  it("isWeb", function(){
    assert.equal(DPApp.uaType(), "web");
  });
});

}else{

describe("App", function(){
  it("isApp", function(){
    assert.equal(DPApp.uaType(), "Zeus");
  });

  it("getVersion", function(done){
    DPApp.getVersion({
      success: function(result){
        assert.equal(result.version, "1.0.0");
        done();
      }
    });
  });

  it("getNetworkType", function(done){
    DPApp.getNetworkType({
      success: function(result){
        assert.equal(result.networkType,"wifi");
        done();
      }
    });
  });

  it("getContactList", function(done){
    DPApp.getContactList({
      success: function(result){
        var list = result.contactList;
        var item = list[0];
        assert(list.length > 0);
        assert(typeof item.firstName, "string");
        assert(typeof item.lastName, "string");
        assert(typeof item.phone, "string");
        done();
      }
    });
  });

  it("getRequestId", function(done){
    DPApp.getRequestId({
      success: function(result){
        assert.equal(result.requestId.length, 36);
        done();
      }
    });
  });

  it("retrieve not exists", function(done){
    DPApp.retrieve({
      key: "notExists",
      success: function(result){
        assert.equal(result.value, "");
        done();
      }
    });
  });

  it("store/retrieve", function(done){
    DPApp.store({
      key: "mykey",
      value: "somevalue"
    })
    .then(function(){
      return DPApp.retrieve({
        key: "mykey"
      })
    })
    .then(function(result){
      assert.equal(result.value, "somevalue");
      done();
    }).catch(done);
  });

  it("subscribe", function(done){
    DPApp.subscribe({
      action: "myevent",
      success: function(result){
        done();
      }
    });
  });

  it("publish", function(done){
    DPApp.publish({
      action: "myevent",
      success: function(result){
        done();
      }
    });
  });

  it("unsubscribe", function(done){
    DPApp.unsubscribe({
      action: "myevent",
      success: function(result){
        done();
      }
    });
  });

  it("downloadImage", function(done){
    DPApp.downloadImage({
      imageUrl: "http://www.dpfile.com/toevent/img/ce066f1113f69fddb5b69355fee46bbe.jpg",
      success: function(){
        done();
      },
      fail: done
    });
  });

  it("setBackgroundColor", function(done){
    DPApp.setBackgroundColor({
      color: "3399dd",
      success: function(){
        done();
      }
    });
  });

  it("setTitle", function(done){
    DPApp.setTitle({
      title: "new Title",
      success: function(){
        done();
      }
    });
  });


  it("setLLButton", function(done){
    DPApp.setLLButton({
      text: "button1",
      icon: "H5_Back",
      success: function(){
        done();
      }
    });
  });

  it("setLRButton", function(done){
    DPApp.setLRButton({
      text: "button2",
      success: function(){
        done();
      }
    });
  });

  it("setRLButton", function(done){
    DPApp.setRLButton({
      text: "button3",
      icon: "H5_Share",
      success: function(){
        done();
      }
    });
  });

  it("setRRButton", function(done){
    DPApp.setRRButton({
      text: "button4",
      icon: "H5_Search",
      success: function(){
        done();
      },
      handle: function(){
        alert("RRButton clicked");
      }
    });
  });
});

}
}, {
    main:true,
    map:mix({"../lib/index":_1,"../lib/network":_2},globalMap)
});

define(_1, [_3,_4,_5,_2], function(require, exports, module, __filename, __dirname) {
var Core = require('./core');
var NativeCore = require('./native-core');
var Network = require('./network');
var Promise = require('promise');

Core.prototype._mixin(Core.prototype, NativeCore);
Core.prototype._mixin(Core.prototype, Network);
Core.prototype.all = function(list){
	return Promise.all(list);
};
module.exports = Core;
}, {
    map:mix({"./core":_4,"./native-core":_5,"./network":_2},globalMap)
});

define(_2, [], function(require, exports, module, __filename, __dirname) {
module.exports = {
  _iOSNetworkType: function (result) {
    var networkType;
    var types = {
      kSCNetworkReachabilityFlagsTransientConnection: 1 << 0,
      kSCNetworkReachabilityFlagsReachable: 1 << 1,
      kSCNetworkReachabilityFlagsConnectionRequired: 1 << 2,
      kSCNetworkReachabilityFlagsConnectionOnTraffic: 1 << 3,
      kSCNetworkReachabilityFlagsInterventionRequired: 1 << 4,
      kSCNetworkReachabilityFlagsConnectionOnDemand: 1 << 5,
      kSCNetworkReachabilityFlagsIsLocalAddress: 1 << 16,
      kSCNetworkReachabilityFlagsIsDirect: 1 << 17,
      kSCNetworkReachabilityFlagsIsWWAN: 1 << 18
    };
    var type = +result.type;
    var subType = result.subType;
    var returnValue;
    // 2g, 3g, 4g
    function getMobileType(subType) {
      switch (subType) {
        case "CTRadioAccessTechnologyGPRS":
        case "CTRadioAccessTechnologyEdge":
        case "CTRadioAccessTechnologyCDMA1x":
          return "2g";
        case "CTRadioAccessTechnologyLTE":
          return "4g";
        case "CTRadioAccessTechnologyWCDMA":
        case "CTRadioAccessTechnologyHSDPA":
        case "CTRadioAccessTechnologyHSUPA":
        case "CTRadioAccessTechnologyCDMA1x":
        case "CTRadioAccessTechnologyCDMAEVDORev0":
        case "CTRadioAccessTechnologyCDMAEVDORevA":
        case "CTRadioAccessTechnologyCDMAEVDORevB":
        case "CTRadioAccessTechnologyeHRPD":
          return "3g";
      }
    }

    if ((type & types.kSCNetworkReachabilityFlagsReachable) == 0) {
      return "none";
    }

    if ((type & types.kSCNetworkReachabilityFlagsConnectionRequired) == 0) {
      // if target host is reachable and no connection is required
      //  then we'll assume (for now) that your on Wi-Fi
      returnValue = "wifi";
    }


    if (
      (type & types.kSCNetworkReachabilityFlagsConnectionOnDemand) != 0
      ||
      (type & types.kSCNetworkReachabilityFlagsConnectionOnTraffic) != 0
    ) {
      // ... and the connection is on-demand (or on-traffic) if the
      //     calling application is using the CFSocketStream or higher APIs
      if ((type & types.kSCNetworkReachabilityFlagsInterventionRequired) == 0) {
        // ... and no [user] intervention is needed
        returnValue = "wifi";
      }
    }

    if ((type & types.kSCNetworkReachabilityFlagsIsWWAN) == types.kSCNetworkReachabilityFlagsIsWWAN) {
      // ... but WWAN connections are OK if the calling application
      //     is using the CFNetwork (CFSocketStream?) APIs.
      returnValue = getMobileType(subType);
    }

    return returnValue;
  },
  _androidNetworkType: function (result) {
    var type = result.type;
    var subType = result.subType;

    if (type == 0) {
      switch (subType) {
        case 1:
        case 2:
        case 4:
        case 7:
        case 11:
          return "2g";
        case 3:
        case 5:
        case 6:
        case 8:
        case 9:
        case 10:
        case 12:
        case 14:
        case 15:
          return "3g";
        case 13:
          return "4g";
      }
    }

    if (type == 1) {
      return "wifi";
    } else {
      return "none";
    }
  },
  getNetworkType : function(opt) {
    var self = this;
    var _success = opt.success;

    this._send("getNetworkType", {
      success: function(result) {
        var ua = self._osUA;
        var networkType;

        switch (ua.name) {
          case "iphone":
            networkType = this._iOSNetworkType(result);
            break;
          case "android":
            networkType = this._androidNetworkType(result);
            break;
        }

        _success && _success({
          networkType: networkType,
          raw: {
            type: result.type,
            subType: result.subType
          }
        });
      },
      fail: opt.fail
    });
  }
}
}, {
    map:globalMap
});

define(_4, [_6,_7], function(require, exports, module, __filename, __dirname) {
function mixin(to, from) {
  for (var key in from) {
    to[key] = from[key];
  }
  return to;
}

var Core = module.exports = function(options){
  options = options || {};
  var self = this;
  for(var key in options){
    this[key] = options[key];
  }


  var apis = options.apis || require('./apis');
  (options.extraApis || []).forEach(function(name){
    if(apis.indexOf(name) === -1){
      apis.push(name);
    }
  });

  this.apis = apis;
  this.allowBeforeReady = this.allowBeforeReady || ["getRequestId"];


  apis.forEach(function(name) {
    if(!self[name]){
      self[name] = function(options) {
        self._send(name, options);
      }
    }
  });

  this.decorate();
};

Core.prototype = {
  _cfg: {
    debug: false
  },
  _isProduct: !!location.href.match(".dianping.com"),
  _isReady: false,
  config: function(config) {
    for(var key in config){
      this._cfg[key] = config[key];
    }
  },
  /**
   * 是否为古早版本
   */
  isOldVersion: function(){
    return false;
  },
  getQuery: function (){
    var query = location.search.slice(1);
    var ret = {};
    query.split("&").forEach(function(pair){
      var splited = pair.split("=");
      ret[splited[0]] = splited[1];
    });
    return ret;
  },
  patchForType: function(version, patch){
    if(this.uaType() == version){
      this.extend(patch);
      this.decorate();
    }
  },
  decorate: require('./decorate'),
  Semver: {
    eq: function(a, b) {
      return a === b;
    },
    gt: function(a, b) {
      var splitedA = a ? a.split(".") : [];
      var splitedB = b ? b.split(".") : [];
      [0,1,2].forEach(function(i){
        splitedA[i] = splitedA[i] || 0;
        splitedB[i] = splitedB[i] || 0;
      });
      if (+splitedA[0] !== +splitedB[0]) {
        return +splitedA[0] > +splitedB[0];
      } else {
        if (+splitedA[1] !== +splitedB[1]) {
          return +splitedA[1] > +splitedB[1];
        } else {
          return +splitedA[2] > +(splitedB[2] || 0);
        }
      }
    },
    lt: function(a, b) {
      return !this.gte(a, b);
    },
    gte: function(a, b) {
      return this.eq(a, b) || this.gt(a, b);
    },
    lte: function(a, b) {
      return this.eq(a, b) || this.lt(a, b);
    }
  },
  _parseUA: function(ua){
    var osName, osVersion, versionMatch;
    if (ua.match(/iPhone/)) {
      osName = "iphone";
      osVersion = ua.match(/iPhone\sOS\s([\d_]+)/i)[1].replace(/_/g, ".");
    } else if (ua.match(/Android/)) {
      osName = "android";
      versionMatch = ua.match(/Android[\s|\/]([\w\.]+)/);
      osVersion = versionMatch && versionMatch[1];
    } else {
      osName = null;
      osVersion = null;
    }
    return {
      name: osName,
      version: osVersion
    }
  },
  getTypeFromUA: function(userAgent){
    return /dp\/com\.dianping\.(\w+)\//.test(userAgent)
      ? userAgent.match(/dp\/com\.dianping\.(\w+)\//)[1]
      : "web"
  },
  uaType: function(){
    return this.getTypeFromUA(navigator.userAgent);
  },
  _trace: function(name, params){
    if(!this.hippoPrefix){return;}
    var logFact = (this._cfg && this._cfg.logFact) || 0.05;
    params = params || {};
    params = this._mixin(params, {
      module: this.hippoPrefix + "_" + name
    });
    if(Math.random() < logFact){
      console.log("_trace", name)
      window._hip && _hip.push(['mv', params]);
    }
  },
  log: function() {

    var message = [];
    for(var i=0; i < arguments.length; i++){
      if(typeof arguments[i] == "string"){
        message.push(arguments[i]);
      }else if(arguments[i] != undefined){
        message.push(JSON.stringify(arguments[i]));
      }
    }

    message = message.join(" ");
    if (this._cfg && this._cfg.debug) {
      setTimeout(function(){
        alert(message);
      });
    }else{
      console.log(message);
    }
  },
  _mixin: mixin,
  extend: function(args) {
    return this._mixin(this, args);
  },
  _notImplemented: function notImplemented(opt) {
    opt && opt.fail && opt.fail({
      errMsg:"ERR_NOT_IMPLEMENTED"
    });
  },
  isSupport: function(funcName) {
    var api = this[funcName];
    return !!(api
      && typeof api == "function"
      && api != this._notImplemented
      && api._notReady != true)
  }
};

Core.prototype._osUA = Core.prototype._parseUA(navigator.userAgent);
}, {
    map:mix({"./apis":_6,"./decorate":_7},globalMap)
});

define(_5, [_8], function(require, exports, module, __filename, __dirname) {
/**
 * count from 1
 * @type {Number}
 */
var _events = {};
var callbacksCount = 1;
/**
 * mapping for all callbacks
 * @type {Object}
 */
var pageEvents = ["appear", "disappear"];
var queue = require('./queue');
var q = queue(function(data){
  DPApp._doSendMessage(data.method, data.args, data.callback);
});

module.exports = {
  _callbacks: (window.DPApp && DPApp._callbacks) ? DPApp._callbacks : {},
	_dequeueTimeout: null,
  dequeue: function(){
    var self = this;
    setTimeout(function(){
      DPApp && DPApp.log && DPApp.log("Dequeue");
      clearTimeout(this._dequeueTimeout);
      self._dequeueTimeout = null;
      q.dequeue();
    }, 0);
  },
  ready: function(callback){
    var self = this;
    this._send("ready", {
      success: function(){
        self._isReady = true;
        callback();
      }
    });
  },
  openScheme: function(opt){
    var url = opt.url;
    var extra = opt.extra;
    if(extra){
      url += "?" + this._convertUrlParams(extra);
      delete opt.extra;
      opt.url = url;
    }
    this._send('openScheme', opt);
  },
  _sendMessage: function(method, args, callback){
    var self = this;
    q.push({
      method: method,
      args: args,
      callback: callback
    });
    this._dequeueTimeout = setTimeout(function(){
      self.dequeue();
    },1000);

  },
  /**
   * send message to native
   * @param  {String}   method
   * @param  {Object}   args
   * @param  {Function} callback
   */
  _doSendMessage: function (method, args, callback) {
      var hasCallback = callback && typeof callback == 'function';
      this.log('调用方法', method, args);

      /**
       * pass 0 as callbackId
       * thus _callbacks[callbackId] is undefined
       * nothing will happen
       * @type {Number}
       */
      var callbackId = hasCallback ? callbacksCount++ : 0;
      if (hasCallback){
        this._callbacks[callbackId] = callback;
      }

      /**
       * check type for args
       */
      if(!args || typeof args !== 'object'){
        args = {};
      }

      // 某些版本app很任性的把callbackId参数放到args里了
      args.callbackId = callbackId;
      args = JSON.stringify(args);

      var bridgeUrl = 'js://_?method=' + method + '&args=' + encodeURIComponent(args) + '&callbackId=' + callbackId;

      this.log('创建iframe ' + method, "callbackId:" + callbackId);
      this._createIframe(bridgeUrl);
  },
  _createNode: function(src, type){
    /**
     * create node
     * and native will intercept and handle the process
     */
    var node = document.createElement(type);
    node.style.display = 'none';

    function removeNode(){
      node.onload = node.onerror = null;
      node.parentNode && node.parentNode.removeChild(node);
    }
    /**
     * remove node after loaded
     */
    node.onload = node.onerror = removeNode;
    setTimeout(removeNode, 5000);
    node.src = src;
    document.body.appendChild(node);
  },
  _createIframe: function(src){
    this._createNode(src, "iframe");
  },
  _send: function(method, args){
    args = args || {};
    var self = this;
    var _success = args.success;
    var _fail = args.fail;
    var _handle = args.handle;

    var fail = function(result){
      self.log('调用失败 ' + method, result);
      _fail && _fail.call(self, result);
    }

    var success = function(result){
      self.log('调用成功 ' + method, result);
      _success && _success.call(self, result);
    }

    var handle = function(result){
      self.log('回调 ' + method, result);
      _handle && _handle.call(self, result);
    }

    var callback = (_success || _fail || _handle) ? function(result){
      var status = result.status;
      if(result.result != "next"){
        delete result.result;
      }
      if(status == "success"){
        success && success(result);
      }else if(status == "action"){
        handle && handle(result);
      }else{
        fail && fail(result);
      }
    } : null;
    this._sendMessage(method, args, callback);
  },

  _convertUrlParams: function(params){
    var result = [];
    for(var i in params){
      result.push(i + "=" + encodeURIComponent(params[i]));
    }
    return result.join("&");
  },
  _sanitizeAjaxOpts: function(args){
    args.method = args.method || "get";
    args.data = args.data || "";
    var url = args.url;
    var data = args.data;

    if (args.method == "get") {
      var params = [];
      for (var p in data) {
        if (data.hasOwnProperty(p) && (data[p] || data[p] === 0)) {  // allow `something=0' param
          params.push(p + '=' + encodeURIComponent(data[p]));
        }
      }

      if (params.length) {
        url += url.indexOf('?') == -1 ? "?" : "&";
        url += params.join('&');
      }
      args.url = url;
      delete args.data;
    }
    return args;
  },
  _parseFeed: function(f){
    var feed;
    if (!f) {
      return 0xff;
    } else if (f.constructor.toString().indexOf("Array") >= 0) {
      feed = [0, 0, 0, 0, 0, 0, 0, 0];
      f.forEach(function(pos) {
        feed[7 - pos] = 1;
      });
      return parseInt(feed.join(""), 2);
    }
  },
  _transModel: function(keys, obj){
    if(!keys){return obj;}
    var keymap = {};

    function getHash(str) {
      var hashCode = function(str) {
        var hash = 0,
          i, chr, len;
        if (str.length == 0) return hash;
        for (i = 0, len = str.length; i < len; i++) {
          chr = str.charCodeAt(i);
          hash = ((hash << 5) - hash) + chr;
          hash |= 0; // Convert to 32bit integer
        }
        return hash;
      };

      var i = hashCode(str);
      return "0x" + ((0xFFFF & i) ^ (i >>> 16)).toString(16);
    }

    function generateKeys(keys) {
      keys.forEach(function(key) {
        keymap[getHash(key)] = key;
      });
    }

    function isArray(val) {
      return Object.prototype.toString.call(val) == "[object Array]";
    }

    function isObject(val) {
      return Object.prototype.toString.call(val) == "[object Object]";
    }

    function translate(obj){
      if (isObject(obj)) {
        delete obj.__name;
        for (var key in obj) {
          var val;
          if (keymap[key]) {
            val = obj[keymap[key]] = obj[key];
            translate(val);
            delete obj[key];
          }
        }
      } else if (isArray(obj)) {
        obj.forEach(function(item) {
          translate(item);
        });
      }
      return obj;
    }

    keys.forEach(function(key) {
      keymap[getHash(key)] = key;
    });

    return translate(obj);
  },
  _capital: function(str){
    return str.slice(0,1).toUpperCase() + str.slice(1);
  },
  subscribe : function(opt) {
    var self = this;
    var name = opt.action;
    var success = opt.success;
    var handle = opt.handle;
    var messageName;

    function mainHandler(e){
      _events[name] && _events[name].length && _events[name].forEach(function(func) {
        func && func(e);
      });
    }

    function registerPageEvents(){
      if(messageName){
        self[messageName] = mainHandler;
        opt.success && opt.success();
      }
    }

    if (_events[name]) {
      opt.success && opt.success();
      _events[name].push(handle);
    } else {
      if(pageEvents.indexOf(name) != -1){
        messageName = "on" + self._capital(name);
        if(name == 'scroll'){
          // 仅scroll事件需要toggle开关
          this._send(messageName, {
            success: registerPageEvents
          });
        }else{
          // 不然就直接注册上了
          registerPageEvents();
        }
      }else{
        this._send("subscribe", {
          action: name,
          success: opt.success,
          handle: mainHandler
        });
      }

      _events[name] = [handle];
    }
  },

  unsubscribe : function(opt) {
    var name = opt.action;
    var success = opt.success;
    var handle = opt.handle;
    var self = this;

    var index = _events[name] ? _events[name].indexOf(handle) : -1;

    function unregisterPageEvents(){
      self[callbackName] = NOOP;
    }

    if (index != -1) {
      _events[name].splice(index, 1);
      success && success();
      if(!_events[name].length){
        _events[name] = null;
      }
    }else if(!handle){
      _events[name] = null;
    }

    if(!_events[name]){
      // unregister
      // if is page event
      if(pageEvents.indexOf(name) != -1 && after7_6){
        var messageName = "off" + self._capital(name);
        var callbackName = "on" + self._capital(name);
        // 与安卓确认
        if(name == 'scroll'){
          this._send(messageName, {
            success: unregisterPageEvents
          });
        }else{
          unregisterPageEvents();
        }
      }else{
        this._send("unsubscribe", {
          action: name,
          success: success
        });
      }
    }
    // if not found, remove all;
  },

  getUA: function(){},
  /**
   * callback function to be invoked from native
   * @param  {Number} callbackId
   * @param  {Object} retValue
   */
  callback: (function (originCallback) {
    return function(callbackId, retValue){
      var self = this;
      if (callbackId && this._callbacks.hasOwnProperty(callbackId)) {
        this.log("触发回调 ", "callbackId:" + callbackId);
        var callback = this._callbacks[callbackId];
        setTimeout(function(){
          callback && callback.call(self,retValue);
        });
        if(retValue.result == "complete" || retValue.result == "error"){
          this._callbacks[callbackId] = null;
          delete this._callbacks[callbackId];
        }
      } else if (typeof originCallback === 'function') {
        var args = arguments;
        setTimeout(function(){
          originCallback.apply(window.DPApp, args);
        });
      }
    };
  })(window.DPApp && window.DPApp.callback)
};
}, {
    map:mix({"./queue":_8},globalMap)
});

define(_6, [], function(require, exports, module, __filename, __dirname) {
module.exports = [
  "getVersion", "getNetworkType", "getContactList", "pickContact",
  "getRequestId", "getDeviceInfo", "clearStorage", "store", "retrieve", "publish", "subscribe", "unsubscribe", "openScheme", "jumpToScheme", "closeWindow", "sendSMS",
  "downloadImage", "setBackgroundColor", "setTitle", "setLLButton", "setLRButton", "setRLButton", "setRRButton", "isInstalledApp",
  "alert", "prompt", "confirm", "actionSheet"
];
}, {
    map:globalMap
});

define(_7, [_3], function(require, exports, module, __filename, __dirname) {
var Promise = require('promise');

module.exports = function (allowBeforeReady){
  var target = this;
  var apis = this.apis;
  var allowBeforeReady = this.allowBeforeReady;

  apis.forEach(function(name){
    if(!target[name]){
      target[name] = target._notImplemented;
    }
  });

  apis.forEach(function(api){
    var _origin = target[api];
    if(target[api] && target[api]._decorated){
      return;
    }
    target[api] = function(args){
      var _args = target._mixin({}, args);
      target._trace(api + "_call");
      var _success = _args.success;
      var _fail = _args.fail;
      var _wrapped_fail = function(result){
        if(!_fail){
          if(target.onerror){
            target.onerror({
              api: api,
              err: result
            });
          }else{
            var errorMessage = result.errMsg ? result.errMsg : JSON.stringify(result);
            var err = new Error(errorMessage);
            err.name = "DPAppError";
            console.warn("`DPApp." + api + "` call faild");
            target._trace('throw');
            console.warn(new Error(err));
          }
        }else{
          _fail(result);
        }
      }
      var zero = +new Date;
      _args.success = function(result){
        target._trace(api + "_success", {
          time: +new Date - zero,
        });
        _success && _success(result);
      };
      _args.fail = function(result){
        var note = {};
        note.args = args;
        note.result = result;
        target._trace(api + "_fail", {
          time: +new Date - zero,
          note: JSON.stringify(note)
        });
        _wrapped_fail(result);
      }

      if(!this._isReady
        && allowBeforeReady.indexOf(api) === -1
        && !target._isProduct // 非正式环境
        && target.isOldVersion() // 且非新版本，为了判断环境，必须wrap在DPApp.ready中
      ){
        _wrapped_fail("use `DPApp.ready(fn)` to wrap api calls");
        return;
      }

      return new Promise(function(resolve, reject){
        var origin_success = _args.success;
        var origin_fail = _args.fail;
        var success = function(result){
          origin_success(result);
          resolve(result);
        }
        var fail = function(result){
          origin_fail(result);
          if(!_fail){
            reject(result);
          }
        }
        _args.success = success;
        _args.fail = fail;
        _origin.call(target, _args);
      });
    }
    target[api]._decorated = true;
    target[api]._notReady = _origin == target._notImplemented;

  });
}
}, {
    map:globalMap
});

define(_8, [], function(require, exports, module, __filename, __dirname) {
var queue = module.exports = function(worker){
	var currentData = null;
	var currentCallback = null;
	var q = {
		timeout: null,
		running : false,
		tasks: [],
		push: function(data, cb){
			var callback = cb || function(data){}
			q.tasks.push({
				data: data,
				callback: callback
			});
			setTimeout(function(){
				q.process();
			}, 0);
		},
		dequeue: function(){
			if(currentCallback){
				currentCallback();
			}else{
				q.running = false;
			}
		},
		process: function(){
			if(q.tasks.length && !q.running){
				var task = q.tasks.shift();
				q.running = true;
				currentCallback = function(){
					q.running = false;
					task.callback(task.data);
					q.process();
				};
				currentData = task.data;
				worker(task.data, currentCallback);
			}
		}
	}
	return q;
};
}, {
    map:globalMap
});
})();
    _use("dpapp-core@1.1.0",function(){
        mocha.run();
    });


    </script>
</body>
</html>