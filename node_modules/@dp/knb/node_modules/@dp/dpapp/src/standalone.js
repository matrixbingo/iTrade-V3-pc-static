(function(ENV){


/**
 * @preserve Neuron JavaScript Framework (c) Kael Zhang <i@kael.me>
 */

// Goal
// Manage module dependencies and initialization 

// Non-goal
// > What neuron will never do
// 1. Neuron will never care about non-browser environment
// 2. Neuron core will never care about module loading

'use strict';

var neuron = {
  version: '7.2.0'
};

var NULL = null;
var FALSE = !1;

// // Check and make sure the module is downloaded, 
// // if not, it will download the module
// neuron.load = function (module, callback){
//   callback();
// }

// Check and make sure the module is ready for running factory
// By default, 
// neuron core is only a module manager who doesn't care about module loading, 
// and consider all modules are already ready.
// By attaching `load.js` and `ready.js`, neuron will be an loader
neuron.ready = function (module, callback) {
  callback();
};


// ## ECMAScript5 implementation
//////////////////////////////////////////////////////////////////////

// - methods native object implemented
// - methods native object extends

// codes from mootools, MDC or by Kael Zhang

// ## Indexes

// ### Array.prototype
// - indexOf
// - lastIndexOf
// - filter
// - forEach
// - every
// - map
// - some
// - reduce
// - reduceRight

// ### Object
// - keys
// - create: removed

// ### String.prototype
// - trim
// - trimLeft
// - trimRight

// ## Specification

// ### STANDALONE language enhancement

// - always has no dependencies on Neuron
// - always follow ECMA standard strictly, including logic, exception type
// - throw the same error hint as webkit on a certain exception


function extend(host, methods) {
  for (var name in methods) {
    if (!host[name]) {
      host[name] = methods[name];
    }
  }
}


function implement(host, methods) {
  extend(host.prototype, methods);
}


var TYPE_ERROR = TypeError;


// ref: https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array
implement(Array, {

  // Accessor methods ------------------------

  indexOf: function(value, from) {
    var len = this.length >>> 0;

    from = Number(from) || 0;
    from = Math[from < 0 ? 'ceil' : 'floor'](from);

    if (from < 0) {
      from = Math.max(from + len, 0);
    }

    for (; from < len; from++) {
      if (from in this && this[from] === value) {
        return from;
      }
    }

    return -1;
  },

  lastIndexOf: function(value, from) {
    var len = this.length >>> 0;

    from = Number(from) || len - 1;
    from = Math[from < 0 ? 'ceil' : 'floor'](from);

    if (from < 0) {
      from += len;
    }

    from = Math.min(from, len - 1);

    for (; from >= 0; from--) {
      if (from in this && this[from] === value) {
        return from;
      }
    }

    return -1;
  },


  // Iteration methods -----------------------

  filter: function(fn, thisObject) {
    var ret = [];
    for (var i = 0, len = this.length; i < len; i++) {

      // Kael:
      // Some people might ask: "why we use a `i in this` here?".
      // ECMA:
      // > callback is invoked only for indexes of the array which have assigned values; 
      // > it is not invoked for indexes which have been deleted or which have never been assigned values

      // Besides, `filter` method is not always used with real Arrays, invocations below might happen:

      //     var obj = {length: 4}; obj[3] = 1;
      //     Array.prototype.filter.call({length: 4});
      //     Array.prototype.filter.call($('body'));

      // as well as the lines below
      if ((i in this) && fn.call(thisObject, this[i], i, this)) {
        ret.push(this[i]);
      }
    }

    return ret;
  },

  forEach: function(fn, thisObject) {
    for (var i = 0, len = this.length; i < len; i++) {
      if (i in this) {

        // if fn is not callable, it will throw
        fn.call(thisObject, this[i], i, this);
      }
    }
  },

  every: function(fn, thisObject) {
    for (var i = 0, len = this.length; i < len; i++) {
      if ((i in this) && !fn.call(thisObject, this[i], i, this)) {
        return false;
      }
    }
    return true;
  },

  map: function(fn, thisObject) {
    var ret = [],
      i = 0,
      l = this.length;

    for (; i < l; i++) {

      // if the subject of the index i is deleted, index i should not be contained in the result of array.map()
      if (i in this) {
        ret[i] = fn.call(thisObject, this[i], i, this);
      }
    }
    return ret;
  },

  some: function(fn, thisObject) {
    for (var i = 0, l = this.length; i < l; i++) {
      if ((i in this) && fn.call(thisObject, this[i], i, this)) {
        return true;
      }
    }
    return false;
  },

  reduce: function(fn) {
    if (typeof fn !== 'function') {
      throw new TYPE_ERROR(fn + ' is not an function');
    }

    var self = this,
      len = self.length >>> 0,
      i = 0,
      ret;

    if (arguments.length > 1) {
      ret = arguments[1];

    } else {
      do {
        if (i in self) {
          ret = self[i++];
          break;
        }

        // if array contains no values, no initial value to return
        if (++i >= len) {
          throw new TYPE_ERROR('Reduce of empty array with on initial value');
        }
      } while (true);
    }

    for (; i < len; i++) {
      if (i in self) {
        ret = fn.call(NULL, ret, self[i], i, self);
      }
    }

    return ret;
  },

  reduceRight: function(fn) {
    if (typeof fn !== 'function') {
      throw new TYPE_ERROR(fn + ' is not an function');
    }

    var self = this,
      len = self.length >>> 0,
      i = len - 1,
      ret;

    if (arguments.length > 1) {
      ret = arguments[1];

    } else {
      do {
        if (i in self) {
          ret = self[i--];
          break;
        }
        // if array contains no values, no initial value to return
        if (--i < 0) {
          throw new TYPE_ERROR('Reduce of empty array with on initial value');
        }

      } while (true);
    }

    for (; i >= 0; i--) {
      if (i in self) {
        ret = fn.call(NULL, ret, self[i], i, self);
      }
    }

    return ret;
  }

});


extend(Object, {

  // ~ https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/create ~
  // create: function(o){
  //    if(o !== Object(o) && o !== NULL){
  //        throw new TYPE_ERROR('Object prototype may only be an Object or NULL');
  //    }

  //    function F() {}
  //    F.prototype = o;

  //    return new F();
  // },

  // refs:
  // http://ejohn.org/blog/ecmascript-5-objects-and-properties/
  // http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
  // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/keys
  // https://developer.mozilla.org/en/ECMAScript_DontEnum_attribute
  // http://msdn.microsoft.com/en-us/library/adebfyya(v=vs.94).aspx
  keys: (function() {
    var hasOwnProperty = Object.prototype.hasOwnProperty,
      has_dontEnumBug = !{
        toString: ''
      }.propertyIsEnumerable('toString'),

      // In some old browsers, such as OLD IE, keys below might not be able to iterated with `for-in`,
      // even if each of them is one of current object's own properties  
      NONT_ENUMS = [
        'toString',
        'toLocaleString',
        'valueOf',
        'hasOwnProperty',
        'isPrototypeOf',
        'propertyIsEnumerable',
        'constructor'
      ],

      NONT_ENUMS_LENGTH = NONT_ENUMS.length;

    return function(o) {
      if (o !== Object(o)) {
        throw new TYPE_ERROR('Object.keys called on non-object');
      }

      var ret = [],
        name;

      for (name in o) {
        if (hasOwnProperty.call(o, name)) {
          ret.push(name);
        }
      }

      if (has_dontEnumBug) {
        for (var i = 0; i < NONT_ENUMS_LENGTH; i++) {
          if (hasOwnProperty.call(o, NONT_ENUMS[i])) {
            ret.push(NONT_ENUMS[i]);
          }
        }
      }

      return ret;
    };

  })()

  // for our current OOP pattern, we don't reply on Object based inheritance
  // so Neuron has not implemented the methods of Object such as Object.defineProperty, etc.
});


implement(String, {
  trimLeft: function() {
    return this.replace(/^\s+/, '');
  },

  trimRight: function() {
    return this.replace(/\s+$/, '');
  },

  trim: function() {
    return this.trimLeft().trimRight();
  }
});


// common code slice
//////////////////////////////////////////////////////////////////////
// - constants
// - common methods

// @const
// 'a@1.2.3/abc' -> 
// ['a@1.2.3/abc', 'a', '1.2.3', '/abc']

//                    0 1                2         3
var REGEX_PARSE_ID = /^((?:[^\/])+?)(?:@([^\/]+))?(\/.*)?$/;
// On android 2.2,
// `[^\/]+?` will fail to do the lazy match, but `(?:[^\/])+?` works.
// Shit, go to hell!

// Parses a module id into an object

// @param {string} id path-resolved module identifier
// 'a@1.0.0'    -> 'a@1.0.0'
// 'a'          -> 'a@*'
// 'a/inner'    -> 'a@*/inner'
function parse_module_id (id) {
  var match = id.match(REGEX_PARSE_ID);
  var name = match[1];

  // 'a/inner' -> 'a@latest/inner'
  var version = match[2] || '*';
  var path = match[3] || '';

  // There always be matches
  return format_parsed({
    n: name,
    v: version,
    p: path
  });
}


// Format package id and pkg
// `parsed` -> 'a@1.1.0'
function format_parsed(parsed) {
  var pkg = parsed.n + '@' + parsed.v;
  parsed.id = pkg + parsed.p;
  parsed.k = pkg;
  return parsed;
}


// Legacy
// Old neuron modules will not define a real resolved id.
// We determine the new version by `env.map`
// Since 6.2.0, actually, neuron will and should no longer add file extension arbitrarily,
// because `commonjs-walker@3.x` will do the require resolve during parsing stage.
// But old version of neuron did and will add a `config.ext` to the end of the file.
// So, if commonjs-walker does so, we adds a 
function legacy_transform_id (id, env) {
  return env.map
    ? id
    : id + '.js';
}


// A very simple `mix` method
// copy all properties in the supplier to the receiver
// @param {Object} receiver
// @param {Object} supplier
// @returns {mixed} receiver
function mix(receiver, supplier) {
  for (var c in supplier) {
    receiver[c] = supplier[c];
  }
}


// greedy match:
var REGEX_DIR_MATCHER = /.*(?=\/.*$)/;

// Get the current directory from the location
//
// http://jsperf.com/regex-vs-split/2
// vs: http://jsperf.com/regex-vs-split
function dirname(uri) {
  var m = uri.match(REGEX_DIR_MATCHER);

  // abc/def  -> abc
  // abc      -> abc  // which is different with `path.dirname` of node.js
  // abc/     -> abc
  return m ? m[0] : uri;
}


// Get the relative path to the root of the env
// @returns {string} a module path
function resolve_path (path, env) {
  // '', 'a.png' -> 'a.png'
  // '', './a.png' -> 'a.png'
  // '', '../a.png' -> '../a.png'
  // '/index.js', 'a.png' -> 'a.png'
  return path_join(
    // '' -> '' -> ''
    // '/index.js' -> '/' -> ''
    dirname(env.p).slice(1),
    path
  );
}


// Resolves an id according to env
// @returns {string} a module id
function resolve_id (path, env) {
  path = resolve_path(path, env);
  return path
    ? env.k + '/' + path
    : env.k;
}


// Canonicalize path
// The same as `path.resolve()` of node.js.

// For example:
// path_join('a', 'b')        -> 'a/b'
// path_join('a/b', './c')    -> 'a/b/c'
// path_join('a/b', '../c')   -> 'a/c'
// path_join('a//b', './c')   -> 'a/b/c'

// #75:
// path_join('../abc', './c') -> '../abc/c',

// path_join('', './c')       -> 'c'
// path_join('', '../c')      -> '../c' 
function path_join(from, to) {
  var parts = (from + '/' + to)
    .split('/')
    // Filter empty string:
    // ['', '.', 'c'] -> ['.', 'c']
    .filter(Boolean);
  return normalize_array(parts).join('/');
}


// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalize_array(parts) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  var i = parts.length - 1;
  for (; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);

    } else if (last === '..') {
      parts.splice(i, 1);
      up++;

    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  while (up--) {
    parts.unshift('..');
  }

  return parts;
}


// @param {string} path
function is_path_relative(path) {
  return path.indexOf('./') === 0 || path.indexOf('../') === 0;
}


// var REGEX_LEADING_SLASH = /^\//;
// function removes_leading_slash (str) {
//   return str.replace(REGEX_LEADING_SLASH, '');
// }


function err (message) {
  throw new Error('neuron: ' + message);
}


function module_not_found (id) {
  err("Cannot find module '" + id + "'");
}


// ## A very simple EventEmitter
//////////////////////////////////////////////////////////////////////

var events = {};

// @param {this} self
// @param {string} type
// @returns {Array.<function()>}
function get_event_storage_by_type(type) {
  return events[type] || (events[type] = []);
}


// Register an event once
function on(type, fn) {
  get_event_storage_by_type(type).push(fn);
}


// Emits an event
function emit(type, data) {
  var handlers = get_event_storage_by_type(type);
  handlers.forEach(function(handler) {
    handler(data);
  });
}


neuron.on = on;


// ## Neuron Core: Module Manager
//////////////////////////////////////////////////////////////////////

// ## CommonJS
// Neuron 3.x or newer is not the implementation of any CommonJs proposals
// but only [module/1.0](http://wiki.commonjs.org/wiki/Modules/1.0), one of the stable CommonJs standards.
// And by using neuron and [cortex](http://github.com/cortexjs/cortex), user could write module/1.0 modules.
// Just FORGET `define`.

// ## Naming Conventions of Variables
// All naming of variables should accord to this.

// Take `'a@1.0.0/relative'` for example:

// ### package 
// The package which the current module belongs to.
// - name or package name:  {string} package `name`: 'a'
// - package or package id: {string} contains package `name` and `version` and the splitter `'@'`. 
//   'a@1.0.0' for instance.

// ### module
// A package is consist of several module objects.
// - mod: {object} the module object. use `mod` instead of `module` to avoid confliction
// - id or module id: the descripter that contains package name, version, and path information
//      {string} for example, `'a@1.0.0/relative'` is a module id(entifier)

// ### version
// Package version: '1.0.0'

// ### main entry
// The module of a package that designed to be accessed from the outside

// ### shadow module and module
// A single module may have different contexts and runtime results
// - mod: the original module definition, including factory function, dependencies and so on
// - module: the shadow module, which is inherited from `mod`

////////////////////////////////////////////////////////////////////////////////////////////////


// Parse an id within an environment, and do range mapping, resolving, applying aliases.
// Returns {Object} parsed object
// @param {string} id
// @param {Object=} env the environment module
function parse_id(id, env) {
  // commonjs parser could not parse non-literal argument of `require`
  id || err('null id');

  env || (env = {});
  // {
  //   alias: {
  //     // id -> path
  //     './a' -> './a.js'
  //   }
  // }
  var map = env.map || {};
  id = map[id] || id;

  // Two kinds of id:
  // - relative module path
  // - package name
  // - a module with path loaded by facade or _use
  var parsed;
  var relative = is_path_relative(id);

  // `env` exists, which means the module is accessed by requiring within another module.
  // `id` is something like '../abc'
  if (relative) {
    env.id || module_not_found(id);

    id = resolve_id(id, env);

    // Legacy
    // If >= 6.2.0, there is always a map,
    // and a value of map is always a top level module id.
    // So, only if it is old wrappings, it would come here.
    // Besides, if not a relative id, we should not adds `'.js'` even it is an old wrapping.
    // How ever, we pass `env` to have a double check.
    id = legacy_transform_id(id, env);

    parsed = parse_module_id(id);

  // `id` is something like 'jquery'
  } else {
    // 1. id is a package name
    // 'jquery' -> 'jquery@~1.9.3'
    // 2. id may be is a package id
    // 'jquery@^1.9.3' -> 'jquery@^1.9.3'
    id = env.m && env.m[id] || id;
    // 'jquery' -> {n: 'jquery', v: '*', p: ''}
    // 'jquery@~1.9.3' -> {n: 'jquery', v: '~1.9.3', p: ''}
    parsed = parse_module_id(id);
  }

  
  if (parsed.k === env.k) {
    // if inside the same package of the parent module,
    // it uses a same sub graph of the package
    parsed.graph = env.graph;

  } else {
    // We route a package of certain range to a specific version according to `config.graph`
    // so several modules may point to a same exports
    // if is foreign module, we should parses the graph to the the sub graph
    var sub_graph = get_sub_graph(parsed.k, env.graph) 
      // If sub_graph not found, set it as `[]`
      || [];
    parsed.graph = sub_graph;
    parsed.v = sub_graph[0] || parsed.v;
    format_parsed(parsed);
  }

  return parsed;
}


function get_sub_graph (pkg, graph) {
  var global_graph = NEURON_CONF.graph._;
  var deps = graph
    ? graph[1]
    // If `graph` is undefined, fallback to global_graph
    : global_graph;
  return deps && (pkg in deps)
    // `deps[pkg]` is the graph id for the subtle graph
    ? NEURON_CONF.graph[deps[pkg]]
    : global_graph;
}


// Get the exports
// @param {Object} module
function get_exports(module) {
  // Since 6.0.0, neuron will not emit a "cyclic" event.
  // But, detecing static cyclic dependencies is a piece of cake for compilers, 
  // such as [cortex](http://github.com/cortexjs/cortex)
  return module.loaded
    ? module.exports

    // #82: since 4.5.0, a module only initialize factory functions when `require()`d.
    : generate_exports(module);
}


// Generate the exports of the module
function generate_exports (module) {
  // # 85
  // Before module factory being invoked, mark the module as `loaded`
  // so we will not execute the factory function again.
  
  // `mod.loaded` indicates that a module has already been `require()`d
  // When there are cyclic dependencies, neuron will not fail.
  module.loaded = true;

  // During the execution of factory, 
  // the reference of `module.exports` might be changed.
  // But we still set the `module.exports` as `{}`, 
  // because the module might be `require()`d during the execution of factory 
  // if cyclic dependency occurs.
  var exports = module.exports = {};

  // TODO:
  // Calculate `filename` ahead of time
  var __filename
    // = module.filename 
    = module_id_to_absolute_url(module.id);
  var __dirname = dirname(__filename);

  // to keep the object mod away from the executing context of factory,
  // use `factory` instead `mod.factory`,
  // preventing user from fetching runtime data by 'this'
  var factory = module.factory;
  factory(create_require(module), exports, module, __filename, __dirname);
  return module.exports;
}


var guid = 1;

// Get a shadow module or create a new one if not exists
// facade({ entry: 'a' })
function get_module (id, env, strict) {
  var parsed = parse_id(id, env);
  var graph = parsed.graph;
  var mod = get_mod(parsed);

  var real_id = mod.main
    // if is main module, then use `pkg` as `real_id`
    ? parsed.k
    : parsed.id;

  // `graph` is the list of modules for a certain package
  var module = graph[real_id];

  if (!module) {
    !strict || module_not_found(id);
    // So that `module` could be linked with a unique graph
    module = graph[real_id] = create_shadow_module(mod);
    module.graph = graph;

    // guid
    module.g || (module.g = guid ++);
  }

  return module;
}


// @param {Object} module
// @param {function(exports)} callback
function use_module (module, callback) {
  neuron.ready(module, function () {
    callback(get_exports(module));
  });
}


// Create a mod
function get_mod(parsed) {
  var id = parsed.id;
  return mods[id] || (mods[id] = {
    // package name: 'a'
    n: parsed.n,
    // package version: '1.1.0'
    v: parsed.v,
    // module path: '/b'
    p: parsed.p,
    // module id: 'a@1.1.0/b'
    id: id,
    // package id: 'a@1.1.0'
    k: parsed.k,
    // version map of the current module
    m: {},
    // loading queue
    l: [],
    // If no path, it must be a main entry.
    // Actually, it actually won't happen when defining a module
    main: !parsed.p
    // map: {Object} The map of aliases to real module id
  });
}


// @param {Object} mod Defined data of mod
function create_shadow_module (mod) {
  function F () {
    // callbacks
    this.r = [];
  }
  F.prototype = mod;
  return new F;
}


// Since 4.2.0, neuron would not allow to require an id with version
// TODO:
// for scoped packages
function test_require_id (id) {
  !~id.indexOf('@') || err("id with '@' is prohibited");
}


// use the sandbox to specify the environment for every id that required in the current module 
// @param {Object} env The object of the current module.
// @return {function}
function create_require(env) {
  var require = function(id) {
    // `require('a@0.0.0')` is prohibited.
    test_require_id(id);

    var module = get_module(id, env, true);
    return get_exports(module);
  };

  // @param {string} id Module identifier. 
  // Since 4.2.0, we only allow to asynchronously load a single module
  require.async = function(id, callback) {
    var origin = id;
    if (callback) {
      // `require.async('a@0.0.0')` is prohibited
      test_require_id(id);
      var relative = is_path_relative(id);
      if (relative) {
        id = resolve_id(id, env);
        var entries = env.entries;
        id = entries
          ? test_entries(id, entries) 
            || test_entries(id + '.js', entries) 
            || test_entries(id + '.json', entries)
            || module_not_found(origin)
          : legacy_transform_id(id, env);
      }

      var module = get_module(id, env);
      if (!module.main) {
        if (relative) {
          // If user try to load a non-entry module, it will get a 404 response
          module.a = true;
        } else {
          // We only allow to `require.async` main module or entries of the current package 
          return;
        }
      }

      use_module(module, callback);
    }
  };

  // @param {string} path
  // @returns
  // - {string} if valid
  // - otherwise `undefined`
  require.resolve = function (path) {
    // NO, you should not do this:
    // `require.resolve('jquery')`
    // We only allow to resolve a relative path

    // Trying to load the resources of a foreign package is evil.
    if (is_path_relative(path)) {
      path = resolve_path(path, env);

      // If user try to resolve a url outside the current package
      // it fails silently
      if (!~path.indexOf('../')) {
        var md5 = get_md5(env.k, path);
        path = append_md5_to_path(path, md5);
        return module_id_to_absolute_url(env.k + '/' + path);
      }
    }
  };

  return require;
}


function test_entries (path, entries) {
  return ~entries.indexOf(path)
    ? path
    : FALSE;
}


// ## Script Loader
//////////////////////////////////////////////////////////////////////

var DOC = document;

// never use `document.body` which might be NULL during downloading of the document.
var HEAD = DOC.getElementsByTagName('head')[0];

function load_js(src) {
  var node = DOC.createElement('script');

  node.src = src;
  node.async = true;

  js_onload(node, function() {
    HEAD.removeChild(node);
  });

  // A very tricky way to avoid several problems in iOS webviews, including:
  // - webpage could not scroll down in iOS6
  // - could not maintain vertial offset when history goes back.
  setTimeout(function () {
    HEAD.insertBefore(node, HEAD.firstChild);
  }, 0);
}


var js_onload = DOC.createElement('script').readyState
  // @param {DOMElement} node
  // @param {!function()} callback asset.js makes sure callback is not NULL
  ? function(node, callback) {
    node.onreadystatechange = function() {
      var rs = node.readyState;
      if (rs === 'loaded' || rs === 'complete') {
        node.onreadystatechange = NULL;
        callback.call(this);
      }
    };
  }

  : function(node, callback) {
    node.addEventListener('load', callback, false);
  };
  

// module define
// ---------------------------------------------------------------------------------------------------


// Method to define a module.

// **NOTICE** that `define` has no fault tolerance and type checking since neuron 2.0,
// because `define` method is no longer designed for human developers to use directly.
// `define` should be generated by some develop environment such as [cortex](http://github.com/cortexjs/cortex)
// @private

// @param {string} id (optional) module identifier
// @param {Array.<string>} dependencies ATTENSION! `dependencies` must be array of standard 
//   module id and there will be NO fault tolerance for argument `dependencies`. Be carefull!
// @param {function(...[*])} factory (require, exports, module)
// @param {Object=} options

// @return {undefined}
function define(id, dependencies, factory, options) {
  (options) || (options = {});

  var parsed = parse_id(id);
  if (parsed.p) {
    // Legacy
    // in old times, main entry: 
    // - define(id_without_ext)
    // - define(pkg) <- even older
    // now, main entry: define(id_with_ext)
    parsed.p = legacy_transform_id(parsed.p, options);
    format_parsed(parsed);
  }
  
  var pkg = parsed.k;
  var modMain;
  if (options.main) {
    modMain = mods[pkg];
  }

  // `mod['a@1.1.0']` must be USED before `mod['a@1.1.0/index.js']`,
  // because nobody knows which module is the main entry of 'a@1.1.0'
  // But `mod['a@1.1.0/index.js']` might be DEFINED first.
  var mod = mods[parsed.id] = modMain || mods[parsed.id] || get_mod(parsed);
  if (options.main) {
    mods[pkg] = mod;
    // Set the real id and path
    mix(mod, parsed);
  }
  mix(mod, options);

  // A single module might be defined more than once.
  // use this trick to prevent module redefining, avoiding the subsequent side effect.
  // mod.factory        -> already defined
  // X mod.exports  -> the module initialization is done
  if (!mod.factory) {
    mod.factory = factory;
    mod.deps = dependencies;
    // ['a@0.0.1']  -> {'a' -> 'a@0.0.1'}
    generate_module_version_map(dependencies, mod.m);

    var asyncDeps = options.asyncDeps;
    if (asyncDeps) {
      generate_module_version_map(asyncDeps, mod.m);
    }

    run_callbacks(mod, 'l');
  }
}


// @private
// create version info of the dependencies of current module into current sandbox
// @param {Array.<string>} modules no type detecting
// @param {Object} host

// ['a@~0.1.0', 'b@~2.3.9']
// -> 
// {
//     a: '~0.1.0',
//     b: '~2.3.9'
// }
function generate_module_version_map(modules, host) {
  modules.forEach(function(mod) {
    var name = mod.split('@')[0];
    host[name] = mod;
  });
}


// Run the callbacks
function run_callbacks (object, key) {
  var callbacks = object[key];
  var callback;
  // Mark the module is ready
  // `delete module.c` is not safe
  // #135
  // Android 2.2 might treat `null` as [object Global] and equal it to true,
  // So, never confuse `null` and `false`
  object[key] = FALSE;
  while(callback = callbacks.pop()){
    callback();
  }
}


// The logic to load the javascript file of a package
//////////////////////////////////////////////////////////////////////


function load_module (module, callback) {
  var mod = mods[module.id];
  mod.f = module.f;
  mod.a = module.a;
  var callbacks = mod.l;
  if (callbacks) {
    callbacks.push(callback);
    if (callbacks.length < 2) {
      load_by_module(mod);
    }
  }
}


// Scenarios:
// 1. facade('a/path');
// -> load a/path -> always
// 2. facade('a');
// -> load a.main
// 3. require('a');
// -> deps on a
// 4. require('./path')
// -> deps on a
// 5. require.async('a')
// -> load a.main ->
// 6. require.async('./path')
// -> load a/path
// 7. require.async('b/path'): the entry of a foreign module
// -> forbidden

var pkgs = [];

// Load the script file of a module into the current document
// @param {string} id module identifier
function load_by_module(mod) {
  if (mod.d) {
    return;
  }

  // (D)ownloaded
  // flag to mark the status that a module has already been downloaded
  mod.d = true;

  var isFacade = mod.f;
  var isAsync = mod.a;
  var pkg = mod.k;

  // if one of the current package's entries has already been loaded,
  // and if the current module is not an entry(facade or async)
  if (~pkgs.indexOf(pkg)) {
    if (!isFacade && !isAsync) {
      return;
    }
  } else {
    pkgs.push(pkg);
  }

  var loaded = NEURON_CONF.loaded;
  // is facade ?
  var evidence = isFacade
    // if a facade is loaded, we will push `mod.id` of the facade instead of package id
    // into `loaded`
    ? mod.id
    : pkg;

  if (~loaded.indexOf(evidence)) {
    if (!isAsync) {
      // If the main entrance of the package is already loaded
      // and the current module is not an async module, skip loading.
      // see: declaration of `require.async`
      return;
    }

    // load packages
  } else {
    loaded.push(evidence);
  }

  load_js(module_to_absolute_url(mod));
}

function append_md5_to_path(path, md5){
  var ext = path.match(/\.[\w\d]+$/)[0];
  if(md5){
    return path.replace(new RegExp(ext + "$"), "_" + md5 + ext);
  }else{
    return path;
  }
}

function module_to_absolute_url(mod) {
  var md5 = get_md5(mod.k, mod.main ? (mod.n + ".js") : mod.p.slice(1));
  var id = mod.main
    // if is a main module, we will load the source file by package

    // 1.
    // on use: 'a@1.0.0' (async or sync)
    // -> 'a/1.0.0/a.js'

    // 2.
    // on use: 'a@1.0.0/relative' (sync)
    // -> not an async module, so the module is already packaged inside:
    // -> 'a/1.0.0/a.js'
    ? mod.k + '/' + mod.n + '.js'

    // if is an async module, we will load the source file by module id
    : mod.id;

  var origin_url = module_id_to_absolute_url(id);

  return append_md5_to_path(origin_url, md5);
}

function get_md5(package_id, mod_path){
  return NEURON_CONF.hash && NEURON_CONF.hash[package_id] && NEURON_CONF.hash[package_id][mod_path];
}


// server: 'http://localhost/abc',
// -> http://localhost/abc/<relative>
// @param {string} relative relative module url
function module_id_to_absolute_url(id) {
  var pathname = id.replace('@', '/');
  var base = NEURON_CONF.path;
  base || err('config.path must be specified');
  base = base.replace('{n}', pathname.length % 3 + 1);

  return base + pathname;
}


// ## Graph Isomorphism and Dependency resolving
//////////////////////////////////////////////////////////////////////

// ### module.defined <==> module.factory
// Indicates that a module is defined, but its dependencies might not defined. 

// ### module.ready
// Indicates that a module is ready to be `require()`d which may occurs in two cases
// - A module is defined but has no dependencies
// - A module is defined, and its dependencies are defined, ready or loaded

// ### module.loaded
// Indicates that module.exports has already been generated

// Register the ready callback for a module, and recursively prepares
// @param {Object} module
// @param {function()} callback
// @param {Array=} stack
function ready (module, callback, stack) {
  emit('beforeready', module_id(module) + ':' + module.g);

  if (!module.factory) {
    emit('beforeload', module.id);
    return load_module(module, function () {
      emit('load', module_id(module));
      ready(module, callback, stack);
    });
  }

  var deps = module.deps;
  var counter = deps.length;

  var callbacks = module.r;
  // `module.r` is `[]` in origin.
  // `!callbacks` means the module is ready
  if (!counter || !callbacks) {
    module.r = FALSE;
    emit_ready(module);
    return callback();
  }

  callbacks.push(callback);
  // if already registered, skip checking
  if (callbacks.length > 1) {
    return;
  }

  var cb = function () {
    if (!-- counter) {
      stack.length = 0;
      stack = NULL;
      emit_ready(module);
      run_callbacks(module, 'r');
    }
  };

  stack = stack
    ? [module].concat(stack)
    : [module];

  deps.forEach(function (dep) {
    var child = get_module(dep, module);
    // If the child is already in the stack,
    // which means there might be cyclic dependency, skip it.
    if (~stack.indexOf(child)) {
      return cb();
    }
    ready(child, cb, stack);
  });
}


function emit_ready (module) {
  emit('ready', module_id(module) + ':' + module.g);
}


function module_id (module) {
  return module.main ? module.k : module.id;
}

// @override
neuron.ready = ready;



// Manage configurations
//////////////////////////////////////////////////////////////////////

// var neuron_loaded = [];
var NEURON_CONF = neuron.conf = {
  loaded: [],
  // If `config.tree` is not specified,
  graph: {
    _: {}
  }
};


var SETTERS = {

  // The server where loader will fetch modules from
  // if use `'localhost'` as `base`, switch on debug mode
  'path': function(path) {
    // Make sure
    // - there's one and only one slash at the end
    // - `conf.path` is a directory
    return path.replace(/\/*$/, '/');
  },
  'hash': justReturn,
  'loaded': justReturn,
  'graph': justReturn
};


function justReturn(subject) {
  return subject;
}


function config(conf) {
  var key;
  var setter;
  for (key in conf) {
    setter = SETTERS[key];
    if (setter) {
      NEURON_CONF[key] = setter(conf[key]);
    }
  }
}

neuron.config = config;


// ## Explode public methods
//////////////////////////////////////////////////////////////////////

ENV.neuron = neuron;

// @expose
ENV.define = define;

// @expose
// Attach a module for business facade, for configurations of inline scripts
// if you want a certain biz module to be initialized automatically, the module's exports should contain a method named 'init'
// ### Usage 
// ```
// // require biz modules with configs
// facade({
//   entry: 'app-main-header-bar',
//   data: {
//     icon: 'http://kael.me/u/2012-03/icon.png'
//   }
// });
//  ```
ENV.facade = function (item) {
  use_module_by_id(item.entry, function(method) {
    method.init && method.init(item.data);
  });
};


// private methods only for testing
// avoid using this method in product environment
// @expose
ENV._use = function (id, callback) {
  use_module_by_id(id, callback);
};

// @expose
ENV._load = load_js;


function use_module_by_id (id, callback) {
  var module = get_module(id);
  module.f = true;
  use_module(module, callback);
}



// map of id -> defined module data
var mods = neuron.mods = {};



// Use `this`, and never cares about the environment.
})(this);
neuron.config({
  "graph": {
    "0": [
      "1.4.12",
      {
        "dpapp-core@^1.1.1": 1,
        "mix@^1.0.1": 2,
        "dpapp-share@~0.1.0": 5
      }
    ],
    "1": [
      "1.2.1",
      {
        "mix@^1.0.1": 2,
        "promise@^6.1.0": 3
      }
    ],
    "2": [
      "1.0.1"
    ],
    "3": [
      "6.1.0",
      {
        "asap@^1.0.0": 4
      }
    ],
    "4": [
      "1.0.0"
    ],
    "5": [
      "0.1.0"
    ],
    "_": {
      "dpapp@1.4.12": 0,
      "dpapp@*": 0
    }
  }
});neuron.config({path:"http://j1.s{n}.dpfile.com/mod/"});(function(){
function mix(a,b){for(var k in b){a[k]=b[k];}return a;}
var _0 = "asap@1.0.0/asap.js";
var asyncDepsToMix = {};
var globalMap = asyncDepsToMix;
define(_0, [], function(require, exports, module, __filename, __dirname) {

// Use the fastest possible means to execute a task in a future turn
// of the event loop.

// linked list of tasks (single, with head node)
var head = {task: void 0, next: null};
var tail = head;
var flushing = false;
var requestFlush = void 0;
var isNodeJS = false;

function flush() {
    /* jshint loopfunc: true */

    while (head.next) {
        head = head.next;
        var task = head.task;
        head.task = void 0;
        var domain = head.domain;

        if (domain) {
            head.domain = void 0;
            domain.enter();
        }

        try {
            task();

        } catch (e) {
            if (isNodeJS) {
                // In node, uncaught exceptions are considered fatal errors.
                // Re-throw them synchronously to interrupt flushing!

                // Ensure continuation if the uncaught exception is suppressed
                // listening "uncaughtException" events (as domains does).
                // Continue in next event to avoid tick recursion.
                if (domain) {
                    domain.exit();
                }
                setTimeout(flush, 0);
                if (domain) {
                    domain.enter();
                }

                throw e;

            } else {
                // In browsers, uncaught exceptions are not fatal.
                // Re-throw them asynchronously to avoid slow-downs.
                setTimeout(function() {
                   throw e;
                }, 0);
            }
        }

        if (domain) {
            domain.exit();
        }
    }

    flushing = false;
}

if (typeof process !== "undefined" && process.nextTick) {
    // Node.js before 0.9. Note that some fake-Node environments, like the
    // Mocha test runner, introduce a `process` global without a `nextTick`.
    isNodeJS = true;

    requestFlush = function () {
        process.nextTick(flush);
    };

} else if (typeof setImmediate === "function") {
    // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
    if (typeof window !== "undefined") {
        requestFlush = setImmediate.bind(window, flush);
    } else {
        requestFlush = function () {
            setImmediate(flush);
        };
    }

} else if (typeof MessageChannel !== "undefined") {
    // modern browsers
    // http://www.nonblocking.io/2011/06/windownexttick.html
    var channel = new MessageChannel();
    channel.port1.onmessage = flush;
    requestFlush = function () {
        channel.port2.postMessage(0);
    };

} else {
    // old browsers
    requestFlush = function () {
        setTimeout(flush, 0);
    };
}

function asap(task) {
    tail = tail.next = {
        task: task,
        domain: isNodeJS && process.domain,
        next: null
    };

    if (!flushing) {
        flushing = true;
        requestFlush();
    }
};

module.exports = asap;


}, {
    main:true,
    map:globalMap
});
})();(function(){
function mix(a,b){for(var k in b){a[k]=b[k];}return a;}
var _0 = "asap@^1.0.0";
var _1 = "promise@6.1.0/polyfill-done.js";
var _2 = "promise@6.1.0/lib/core.js";
var _3 = "promise@6.1.0/lib/es6-extensions.js";
var _4 = "promise@6.1.0/polyfill.js";
var asyncDepsToMix = {};
var globalMap = asyncDepsToMix;
define(_4, [_0,_1,_2,_3], function(require, exports, module, __filename, __dirname) {
// not "use strict" so we can declare global "Promise"

var asap = require('asap');

if (typeof Promise === 'undefined') {
  Promise = require('./lib/core.js');
  require('./lib/es6-extensions.js');
}

require('./polyfill-done.js');

module.exports = Promise;
}, {
    main:true,
    map:mix({"./polyfill-done.js":_1,"./lib/core.js":_2,"./lib/es6-extensions.js":_3},globalMap)
});

define(_1, [], function(require, exports, module, __filename, __dirname) {
// should work in any browser without browserify

if (typeof Promise.prototype.done !== 'function') {
  Promise.prototype.done = function (onFulfilled, onRejected) {
    var self = arguments.length ? this.then.apply(this, arguments) : this
    self.then(null, function (err) {
      setTimeout(function () {
        throw err
      }, 0)
    })
  }
}
}, {
    map:globalMap
});

define(_2, [_0], function(require, exports, module, __filename, __dirname) {
'use strict';

var asap = require('asap')

module.exports = Promise;
function Promise(fn) {
  if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new')
  if (typeof fn !== 'function') throw new TypeError('not a function')
  var state = null
  var value = null
  var deferreds = []
  var self = this

  this.then = function(onFulfilled, onRejected) {
    return new self.constructor(function(resolve, reject) {
      handle(new Handler(onFulfilled, onRejected, resolve, reject))
    })
  }

  function handle(deferred) {
    if (state === null) {
      deferreds.push(deferred)
      return
    }
    asap(function() {
      var cb = state ? deferred.onFulfilled : deferred.onRejected
      if (cb === null) {
        (state ? deferred.resolve : deferred.reject)(value)
        return
      }
      var ret
      try {
        ret = cb(value)
      }
      catch (e) {
        deferred.reject(e)
        return
      }
      deferred.resolve(ret)
    })
  }

  function resolve(newValue) {
    try { //Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.')
      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
        var then = newValue.then
        if (typeof then === 'function') {
          doResolve(then.bind(newValue), resolve, reject)
          return
        }
      }
      state = true
      value = newValue
      finale()
    } catch (e) { reject(e) }
  }

  function reject(newValue) {
    state = false
    value = newValue
    finale()
  }

  function finale() {
    for (var i = 0, len = deferreds.length; i < len; i++)
      handle(deferreds[i])
    deferreds = null
  }

  doResolve(fn, resolve, reject)
}


function Handler(onFulfilled, onRejected, resolve, reject){
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null
  this.onRejected = typeof onRejected === 'function' ? onRejected : null
  this.resolve = resolve
  this.reject = reject
}

/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, onFulfilled, onRejected) {
  var done = false;
  try {
    fn(function (value) {
      if (done) return
      done = true
      onFulfilled(value)
    }, function (reason) {
      if (done) return
      done = true
      onRejected(reason)
    })
  } catch (ex) {
    if (done) return
    done = true
    onRejected(ex)
  }
}

}, {
    map:globalMap
});

define(_3, [_0,_2], function(require, exports, module, __filename, __dirname) {
'use strict';

//This file contains the ES6 extensions to the core Promises/A+ API

var Promise = require('./core.js')
var asap = require('asap')

module.exports = Promise

/* Static Functions */

function ValuePromise(value) {
  this.then = function (onFulfilled) {
    if (typeof onFulfilled !== 'function') return this
    return new Promise(function (resolve, reject) {
      asap(function () {
        try {
          resolve(onFulfilled(value))
        } catch (ex) {
          reject(ex);
        }
      })
    })
  }
}
ValuePromise.prototype = Promise.prototype

var TRUE = new ValuePromise(true)
var FALSE = new ValuePromise(false)
var NULL = new ValuePromise(null)
var UNDEFINED = new ValuePromise(undefined)
var ZERO = new ValuePromise(0)
var EMPTYSTRING = new ValuePromise('')

Promise.resolve = function (value) {
  if (value instanceof Promise) return value

  if (value === null) return NULL
  if (value === undefined) return UNDEFINED
  if (value === true) return TRUE
  if (value === false) return FALSE
  if (value === 0) return ZERO
  if (value === '') return EMPTYSTRING

  if (typeof value === 'object' || typeof value === 'function') {
    try {
      var then = value.then
      if (typeof then === 'function') {
        return new Promise(then.bind(value))
      }
    } catch (ex) {
      return new Promise(function (resolve, reject) {
        reject(ex)
      })
    }
  }

  return new ValuePromise(value)
}

Promise.all = function (arr) {
  var args = Array.prototype.slice.call(arr)

  return new Promise(function (resolve, reject) {
    if (args.length === 0) return resolve([])
    var remaining = args.length
    function res(i, val) {
      try {
        if (val && (typeof val === 'object' || typeof val === 'function')) {
          var then = val.then
          if (typeof then === 'function') {
            then.call(val, function (val) { res(i, val) }, reject)
            return
          }
        }
        args[i] = val
        if (--remaining === 0) {
          resolve(args);
        }
      } catch (ex) {
        reject(ex)
      }
    }
    for (var i = 0; i < args.length; i++) {
      res(i, args[i])
    }
  })
}

Promise.reject = function (value) {
  return new Promise(function (resolve, reject) { 
    reject(value);
  });
}

Promise.race = function (values) {
  return new Promise(function (resolve, reject) { 
    values.forEach(function(value){
      Promise.resolve(value).then(resolve, reject);
    })
  });
}

/* Prototype Methods */

Promise.prototype['catch'] = function (onRejected) {
  return this.then(null, onRejected);
}

}, {
    map:mix({"./core.js":_2},globalMap)
});
})();(function(){
function mix(a,b){for(var k in b){a[k]=b[k];}return a;}
var _0 = "mix@1.0.1/index.js";
var asyncDepsToMix = {};
var globalMap = asyncDepsToMix;
define(_0, [], function(require, exports, module, __filename, __dirname) {
'use strict';

module.exports = mix;


// copy all properties in the supplier to the receiver
// @param r {Object} receiver
// @param s {Object} supplier
// @param or {boolean=} whether override the existing property in the receiver
// @param cl {(Array.<string>)=} copy list, an array of selected properties
function mix (r, s, or, cl) {
  if (!s || !r) {
    return r;
  }

  var i = 0,
    c, len;

  or = or || arguments.length === 2;

  if (cl && (len = cl.length)) {
    for (; i < len; i++) {
      c = cl[i];
      if ((c in s) && (or || !(c in r))) {
        r[c] = s[c];
      }
    }
  } else {
    for (c in s) {
      if (or || !(c in r)) {
        r[c] = s[c];
      }
    }
  }
  return r;
};

}, {
    main:true,
    map:globalMap
});
})();(function(){
function mix(a,b){for(var k in b){a[k]=b[k];}return a;}
var _0 = "promise@^6.1.0";
var _1 = "dpapp-core@1.2.1/lib/core.js";
var _2 = "dpapp-core@1.2.1/lib/native-core.js";
var _3 = "dpapp-core@1.2.1/lib/network.js";
var _4 = "dpapp-core@1.2.1/lib/apis.js";
var _5 = "dpapp-core@1.2.1/lib/decorate.js";
var _6 = "dpapp-core@1.2.1/lib/queue.js";
var _7 = "dpapp-core@1.2.1/lib/index.js";
var asyncDepsToMix = {};
var globalMap = asyncDepsToMix;
define(_7, [_0,_1,_2,_3], function(require, exports, module, __filename, __dirname) {
var Core = require('./core');
var NativeCore = require('./native-core');
var Network = require('./network');
var Promise = require('promise');

Core.prototype._mixin(Core.prototype, NativeCore);
Core.prototype._mixin(Core.prototype, Network);
Core.prototype.all = function(list){
	return Promise.all(list);
};
module.exports = Core;
}, {
    main:true,
    map:mix({"./core":_1,"./native-core":_2,"./network":_3},globalMap)
});

define(_1, [_4,_5], function(require, exports, module, __filename, __dirname) {
function mixin(to, from) {
  for (var key in from) {
    to[key] = from[key];
  }
  return to;
}

var Core = module.exports = function(options){
  options = options || {};
  var self = this;
  for(var key in options){
    this[key] = options[key];
  }


  var apis = options.apis || require('./apis');
  (options.extraApis || []).forEach(function(name){
    if(apis.indexOf(name) === -1){
      apis.push(name);
    }
  });

  this.apis = apis;
  this.allowBeforeReady = this.allowBeforeReady || ["getRequestId"];


  apis.forEach(function(name) {
    if(!self[name]){
      self[name] = function(options) {
        self._send(name, options);
      }
    }
  });

  this.decorate();
};

Core.prototype = {
  _cfg: {
    debug: false
  },
  _isProduct: !!location.href.match(".dianping.com"),
  _isReady: false,
  config: function(config) {
    for(var key in config){
      this._cfg[key] = config[key];
    }
  },
  /**
   * 是否为古早版本
   */
  isOldVersion: function(){
    return false;
  },
  getQuery: function (){
    var query = location.search.slice(1);
    var ret = {};
    query.split("&").forEach(function(pair){
      var splited = pair.split("=");
      ret[splited[0]] = splited[1];
    });
    return ret;
  },
  patchForType: function(version, patch){
    if(this.uaType() == version){
      this.extend(patch);
      this.decorate();
    }
  },
  decorate: require('./decorate'),
  Semver: {
    eq: function(a, b) {
      return a === b;
    },
    gt: function(a, b) {
      var splitedA = a ? a.split(".") : [];
      var splitedB = b ? b.split(".") : [];
      [0,1,2].forEach(function(i){
        splitedA[i] = splitedA[i] || 0;
        splitedB[i] = splitedB[i] || 0;
      });
      if (+splitedA[0] !== +splitedB[0]) {
        return +splitedA[0] > +splitedB[0];
      } else {
        if (+splitedA[1] !== +splitedB[1]) {
          return +splitedA[1] > +splitedB[1];
        } else {
          return +splitedA[2] > +(splitedB[2] || 0);
        }
      }
    },
    lt: function(a, b) {
      return !this.gte(a, b);
    },
    gte: function(a, b) {
      return this.eq(a, b) || this.gt(a, b);
    },
    lte: function(a, b) {
      return this.eq(a, b) || this.lt(a, b);
    }
  },
  _parseUA: function(ua){
    var osName, osVersion, versionMatch;
    if (ua.match(/iPhone/)) {
      osName = "iphone";
      osVersion = ua.match(/iPhone\sOS\s([\d_]+)/i)[1].replace(/_/g, ".");
    } else if (ua.match(/Android/)) {
      osName = "android";
      versionMatch = ua.match(/Android[\s|\/]([\w\.]+)/);
      osVersion = versionMatch && versionMatch[1];
    } else {
      osName = null;
      osVersion = null;
    }
    return {
      name: osName,
      version: osVersion
    }
  },
  getTypeFromUA: function(userAgent){
    return /dp\/com\.dianping\.(\w+)\//.test(userAgent)
      ? userAgent.match(/dp\/com\.dianping\.(\w+)\//)[1]
      : "web"
  },
  uaType: function(){
    return this.getTypeFromUA(navigator.userAgent);
  },
  _trace: function(name, params){
    if(!this.hippoPrefix){return;}
    var logFact = (this._cfg && this._cfg.logFact) || 0.05;
    params = params || {};
    params = this._mixin(params, {
      module: this.hippoPrefix + "_" + name
    });
    if(Math.random() < logFact){
      console.log("_trace", name)
      window._hip && _hip.push(['mv', params]);
    }
  },
  log: function() {

    var message = [];
    for(var i=0; i < arguments.length; i++){
      if(typeof arguments[i] == "string"){
        message.push(arguments[i]);
      }else if(arguments[i] != undefined){
        message.push(JSON.stringify(arguments[i]));
      }
    }

    message = message.join(" ");
    if (this._cfg && this._cfg.debug) {
      setTimeout(function(){
        alert(message);
      });
    }else{
      console.log(message);
    }
  },
  _mixin: mixin,
  extend: function(args) {
    return this._mixin(this, args);
  },
  _notImplemented: function notImplemented(opt) {
    opt && opt.fail && opt.fail({
      errMsg:"ERR_NOT_IMPLEMENTED"
    });
  },
  isSupport: function(funcName) {
    var api = this[funcName];
    return !!(api
      && typeof api == "function"
      && api != this._notImplemented
      && api._notReady != true)
  }
};

Core.prototype._osUA = Core.prototype._parseUA(navigator.userAgent);
}, {
    map:mix({"./apis":_4,"./decorate":_5},globalMap)
});

define(_2, [_6], function(require, exports, module, __filename, __dirname) {
/**
 * count from 1
 * @type {Number}
 */
var _events = {};
/**
 * mapping for all callbacks
 * @type {Object}
 */
var pageEvents = ["appear", "disappear"];
var queue = require('./queue');
var q = queue(function(data){
  DPApp._doSendMessage(data.method, data.args, data.callback);
});

module.exports = {
	_dequeueTimeout: null,
  _messageQueue : q,
  dequeue: function(){
    var self = this;
    setTimeout(function(){
      DPApp && DPApp.log && DPApp.log("Dequeue");
      clearTimeout(this._dequeueTimeout);
      self._dequeueTimeout = null;
      q.dequeue();
    }, 0);
  },
  ready: function(callback){
    var self = this;
    this._send("ready", {
      success: function(){
        self._isReady = true;
        callback();
      }
    });
  },
  openScheme: function(opt){
    var url = opt.url;
    var extra = opt.extra;
    if(extra){
      url += "?" + this._convertUrlParams(extra);
      delete opt.extra;
      opt.url = url;
    }
    this._send('openScheme', opt);
  },
  _sendMessage: function(method, args, callback){
    var self = this;
    q.push({
      method: method,
      args: args,
      callback: callback
    });
    this._dequeueTimeout = setTimeout(function(){
      self.dequeue();
    },1000);

  },
  // _generateCallbackId: function(){
  //   var rand = Math.floor(Math.random() * 1000);
  //   var timestamp = +new Date();
  //   return +(timestamp + "" + rand);
  // },
  _generateCallbackId: function () {
    var rand = Math.floor(Math.random() * 1000);
    var timestampStr = (+new Date()).toString();
    //在DPAPP老版本中callbackId为int型，故只选取8位
    var timestamp = timestampStr.substr(timestampStr.length - 5, 5);
    return +(timestamp + "" + rand);
  },
  _generateCallbackName: function(callbackId){
    return "DPApp_callback_" + callbackId;
  },
  /**
   * send message to native
   * @param  {String}   method
   * @param  {Object}   args
   * @param  {Function} callback
   */
  _doSendMessage: function (method, args, callback) {
      var hasCallback = callback && typeof callback == 'function';
      this.log('调用方法', method, args);

      /**
       * pass 0 as callbackId
       * thus _callbacks[callbackId] is undefined
       * nothing will happen
       * @type {Number}
       */
      var callbackId = hasCallback ? this._generateCallbackId() : 0;
      
      if (hasCallback){
        window[this._generateCallbackName(callbackId)] = callback;
      }

      /**
       * check type for args
       */
      if(!args || typeof args !== 'object'){
        args = {};
      }

      // 某些版本app很任性的把callbackId参数放到args里了
      args.callbackId = callbackId;
      args = JSON.stringify(args);

      var bridgeUrl = 'js://_?method=' + method + '&args=' + encodeURIComponent(args) + '&callbackId=' + callbackId;

      this.log('创建iframe ' + method, "callbackId:" + callbackId);
      this._createIframe(bridgeUrl);
  },
  _createNode: function(src, type){
    /**
     * create node
     * and native will intercept and handle the process
     */
    var node = document.createElement(type);
    node.style.display = 'none';

    function removeNode(){
      node.onload = node.onerror = null;
      node.parentNode && node.parentNode.removeChild(node);
    }
    /**
     * remove node after loaded
     */
    node.onload = node.onerror = removeNode;
    setTimeout(removeNode, 5000);
    node.src = src;
    document.body.appendChild(node);
  },
  _createIframe: function(src){
    this._createNode(src, "iframe");
  },
  _send: function(method, args){
    args = args || {};
    var self = this;
    var _success = args.success;
    var _fail = args.fail;
    var _handle = args.handle;

    var fail = function(result){
      self.log('调用失败 ' + method, result);
      _fail && _fail.call(self, result);
    }

    var success = function(result){
      self.log('调用成功 ' + method, result);
      _success && _success.call(self, result);
    }

    var handle = function(result){
      self.log('回调 ' + method, result);
      _handle && _handle.call(self, result);
    }

    var callback = (_success || _fail || _handle) ? function(result){
      var status = result.status;
      if(result.result != "next"){
        delete result.result;
      }
      if(status == "success"){
        success && success(result);
      }else if(status == "action"){
        handle && handle(result);
      }else{
        fail && fail(result);
      }
    } : null;

    this._sendMessage(method, args, callback);

  },

  _convertUrlParams: function(params){
    var result = [];
    for(var i in params){
      result.push(i + "=" + encodeURIComponent(params[i]));
    }
    return result.join("&");
  },
  _sanitizeAjaxOpts: function(args){
    args.method = args.method || "get";
    args.data = args.data || "";
    var url = args.url;
    var data = args.data;

    if (args.method == "get") {
      var params = [];
      for (var p in data) {
        if (data.hasOwnProperty(p) && (data[p] || data[p] === 0)) {  // allow `something=0' param
          params.push(p + '=' + encodeURIComponent(data[p]));
        }
      }

      if (params.length) {
        url += url.indexOf('?') == -1 ? "?" : "&";
        url += params.join('&');
      }
      args.url = url;
      delete args.data;
    }
    return args;
  },
  _parseFeed: function(f){
    var feed;
    if (!f) {
      return 0xff;
    } else if (f.constructor.toString().indexOf("Array") >= 0) {
      feed = [0, 0, 0, 0, 0, 0, 0, 0];
      f.forEach(function(pos) {
        feed[7 - pos] = 1;
      });
      return parseInt(feed.join(""), 2);
    }
  },
  _transModel: function(keys, obj){
    if(!keys){return obj;}
    var keymap = {};

    function getHash(str) {
      var hashCode = function(str) {
        var hash = 0,
          i, chr, len;
        if (str.length == 0) return hash;
        for (i = 0, len = str.length; i < len; i++) {
          chr = str.charCodeAt(i);
          hash = ((hash << 5) - hash) + chr;
          hash |= 0; // Convert to 32bit integer
        }
        return hash;
      };

      var i = hashCode(str);
      return "0x" + ((0xFFFF & i) ^ (i >>> 16)).toString(16);
    }

    function generateKeys(keys) {
      keys.forEach(function(key) {
        keymap[getHash(key)] = key;
      });
    }

    function isArray(val) {
      return Object.prototype.toString.call(val) == "[object Array]";
    }

    function isObject(val) {
      return Object.prototype.toString.call(val) == "[object Object]";
    }

    function translate(obj){
      if (isObject(obj)) {
        delete obj.__name;
        for (var key in obj) {
          var val;
          if (keymap[key]) {
            val = obj[keymap[key]] = obj[key];
            translate(val);
            delete obj[key];
          }
        }
      } else if (isArray(obj)) {
        obj.forEach(function(item) {
          translate(item);
        });
      }
      return obj;
    }

    keys.forEach(function(key) {
      keymap[getHash(key)] = key;
    });

    return translate(obj);
  },
  _capital: function(str){
    return str.slice(0,1).toUpperCase() + str.slice(1);
  },
  subscribe : function(opt) {
    var self = this;
    var name = opt.action;
    var success = opt.success;
    var handle = opt.handle;
    var messageName;

    function mainHandler(e){
      _events[name] && _events[name].length && _events[name].forEach(function(func) {
        func && func(e);
      });
    }

    function registerPageEvents(){
      if(messageName){
        self[messageName] = mainHandler;
        opt.success && opt.success();
      }
    }

    if (_events[name]) {
      opt.success && opt.success();
      _events[name].push(handle);
    } else {
      if(pageEvents.indexOf(name) != -1){
        messageName = "on" + self._capital(name);
        if(name == 'scroll'){
          // 仅scroll事件需要toggle开关
          this._send(messageName, {
            success: registerPageEvents
          });
        }else{
          // 不然就直接注册上了
          registerPageEvents();
        }
      }else{
        this._send("subscribe", {
          action: name,
          success: opt.success,
          handle: mainHandler
        });
      }

      _events[name] = [handle];
    }
  },

  unsubscribe : function(opt) {
    var name = opt.action;
    var success = opt.success;
    var handle = opt.handle;
    var self = this;

    var index = _events[name] ? _events[name].indexOf(handle) : -1;

    function unregisterPageEvents(){
      self[callbackName] = NOOP;
    }

    if (index != -1) {
      _events[name].splice(index, 1);
      success && success();
      if(!_events[name].length){
        _events[name] = null;
      }
    }else if(!handle){
      _events[name] = null;
    }

    if(!_events[name]){
      // unregister
      // if is page event
      if(pageEvents.indexOf(name) != -1 && after7_6){
        var messageName = "off" + self._capital(name);
        var callbackName = "on" + self._capital(name);
        // 与安卓确认
        if(name == 'scroll'){
          this._send(messageName, {
            success: unregisterPageEvents
          });
        }else{
          unregisterPageEvents();
        }
      }else{
        this._send("unsubscribe", {
          action: name,
          success: success
        });
      }
    }
    // if not found, remove all;
  },

  getUA: function(){},
  /**
   * callback function to be invoked from native
   * @param  {Number} callbackId
   * @param  {Object} retValue
   */
  callback: function(callbackId, retValue){
    var win = window;
    var callbackFuncName = this._generateCallbackName(callbackId);
    var callback = window[callbackFuncName];

    if(callback){
      this.log("触发回调 ", "callbackId:" + callbackId);
      setTimeout(function(){
        callback && callback.call(self,retValue);
      });
      if(retValue.result == "complete" || retValue.result == "error"){
        win[callbackFuncName] = null;
        delete win[callbackFuncName];
      }
    }
  }
};
}, {
    map:mix({"./queue":_6},globalMap)
});

define(_3, [], function(require, exports, module, __filename, __dirname) {
module.exports = {
  _iOSNetworkType: function (result) {
    var networkType;
    var types = {
      kSCNetworkReachabilityFlagsTransientConnection: 1 << 0,
      kSCNetworkReachabilityFlagsReachable: 1 << 1,
      kSCNetworkReachabilityFlagsConnectionRequired: 1 << 2,
      kSCNetworkReachabilityFlagsConnectionOnTraffic: 1 << 3,
      kSCNetworkReachabilityFlagsInterventionRequired: 1 << 4,
      kSCNetworkReachabilityFlagsConnectionOnDemand: 1 << 5,
      kSCNetworkReachabilityFlagsIsLocalAddress: 1 << 16,
      kSCNetworkReachabilityFlagsIsDirect: 1 << 17,
      kSCNetworkReachabilityFlagsIsWWAN: 1 << 18
    };
    var type = +result.type;
    var subType = result.subType;
    var returnValue;
    // 2g, 3g, 4g
    function getMobileType(subType) {
      switch (subType) {
        case "CTRadioAccessTechnologyGPRS":
        case "CTRadioAccessTechnologyEdge":
        case "CTRadioAccessTechnologyCDMA1x":
          return "2g";
        case "CTRadioAccessTechnologyLTE":
          return "4g";
        case "CTRadioAccessTechnologyWCDMA":
        case "CTRadioAccessTechnologyHSDPA":
        case "CTRadioAccessTechnologyHSUPA":
        case "CTRadioAccessTechnologyCDMA1x":
        case "CTRadioAccessTechnologyCDMAEVDORev0":
        case "CTRadioAccessTechnologyCDMAEVDORevA":
        case "CTRadioAccessTechnologyCDMAEVDORevB":
        case "CTRadioAccessTechnologyeHRPD":
          return "3g";
      }
    }

    if ((type & types.kSCNetworkReachabilityFlagsReachable) == 0) {
      return "none";
    }

    if ((type & types.kSCNetworkReachabilityFlagsConnectionRequired) == 0) {
      // if target host is reachable and no connection is required
      //  then we'll assume (for now) that your on Wi-Fi
      returnValue = "wifi";
    }


    if (
      (type & types.kSCNetworkReachabilityFlagsConnectionOnDemand) != 0
      ||
      (type & types.kSCNetworkReachabilityFlagsConnectionOnTraffic) != 0
    ) {
      // ... and the connection is on-demand (or on-traffic) if the
      //     calling application is using the CFSocketStream or higher APIs
      if ((type & types.kSCNetworkReachabilityFlagsInterventionRequired) == 0) {
        // ... and no [user] intervention is needed
        returnValue = "wifi";
      }
    }

    if ((type & types.kSCNetworkReachabilityFlagsIsWWAN) == types.kSCNetworkReachabilityFlagsIsWWAN) {
      // ... but WWAN connections are OK if the calling application
      //     is using the CFNetwork (CFSocketStream?) APIs.
      returnValue = getMobileType(subType);
    }

    return returnValue;
  },
  _androidNetworkType: function (result) {
    var type = result.type;
    var subType = result.subType;

    if (type == 0) {
      switch (subType) {
        case 1:
        case 2:
        case 4:
        case 7:
        case 11:
          return "2g";
        case 3:
        case 5:
        case 6:
        case 8:
        case 9:
        case 10:
        case 12:
        case 14:
        case 15:
          return "3g";
        case 13:
          return "4g";
      }
    }

    if (type == 1) {
      return "wifi";
    } else {
      return "none";
    }
  },
  getNetworkType : function(opt) {
    var self = this;
    var _success = opt.success;

    this._send("getNetworkType", {
      success: function(result) {
        var ua = self._osUA;
        var networkType;

        switch (ua.name) {
          case "iphone":
            networkType = this._iOSNetworkType(result);
            break;
          case "android":
            networkType = this._androidNetworkType(result);
            break;
        }

        _success && _success({
          networkType: networkType,
          raw: {
            type: result.type,
            subType: result.subType
          }
        });
      },
      fail: opt.fail
    });
  }
}
}, {
    map:globalMap
});

define(_4, [], function(require, exports, module, __filename, __dirname) {
module.exports = [
  "getVersion", "getNetworkType", "getContactList", "pickContact",
  "getRequestId", "getDeviceInfo", "clearStorage", "store", "retrieve", "publish", "subscribe", "unsubscribe", "openScheme", "jumpToScheme", "closeWindow", "sendSMS",
  "downloadImage", "setBackgroundColor", "setTitle", "setLLButton", "setLRButton", "setRLButton", "setRRButton", "isInstalledApp",
  "alert", "prompt", "confirm", "actionSheet"
];
}, {
    map:globalMap
});

define(_5, [_0], function(require, exports, module, __filename, __dirname) {
var Promise = require('promise');

module.exports = function (allowBeforeReady){
  var target = this;
  var apis = this.apis;
  var allowBeforeReady = this.allowBeforeReady;

  apis.forEach(function(name){
    if(!target[name]){
      target[name] = target._notImplemented;
    }
  });

  apis.forEach(function(api){
    var _origin = target[api];
    if(target[api] && target[api]._decorated){
      return;
    }
    target[api] = function(args){
      var _args = target._mixin({}, args);
      target._trace(api + "_call");
      var _success = _args.success;
      var _fail = _args.fail;
      var _wrapped_fail = function(result){
        if(!_fail){
          if(target.onerror){
            target.onerror({
              api: api,
              err: result
            });
          }else{
            var errorMessage = result.errMsg ? result.errMsg : JSON.stringify(result);
            var err = new Error(errorMessage);
            err.name = "DPAppError";
            console.warn("`DPApp." + api + "` call faild");
            target._trace('throw');
            console.warn(new Error(err));
          }
        }else{
          _fail(result);
        }
      }
      var zero = +new Date;
      _args.success = function(result){
        target._trace(api + "_success", {
          time: +new Date - zero,
        });
        _success && _success(result);
      };
      _args.fail = function(result){
        var note = {};
        note.args = args;
        note.result = result;
        target._trace(api + "_fail", {
          time: +new Date - zero,
          note: JSON.stringify(note)
        });
        _wrapped_fail(result);
      }

      if(!this._isReady
        && allowBeforeReady.indexOf(api) === -1
        && !target._isProduct // 非正式环境
        && target.isOldVersion() // 且非新版本，为了判断环境，必须wrap在DPApp.ready中
      ){
        _wrapped_fail("use `DPApp.ready(fn)` to wrap api calls");
        return;
      }

      return new Promise(function(resolve, reject){
        var origin_success = _args.success;
        var origin_fail = _args.fail;
        var success = function(result){
          origin_success(result);
          resolve(result);
        }
        var fail = function(result){
          origin_fail(result);
          if(!_fail){
            reject(result);
          }
        }
        _args.success = success;
        _args.fail = fail;
        _origin.call(target, _args);
      });
    }
    target[api]._decorated = true;
    target[api]._notReady = _origin == target._notImplemented;

  });
}
}, {
    map:globalMap
});

define(_6, [], function(require, exports, module, __filename, __dirname) {
var queue = module.exports = function(worker){
	var currentData = null;
	var currentCallback = null;
	var q = {
		timeout: null,
		running : false,
		tasks: [],
		push: function(data, cb){
			var callback = cb || function(data){}
			q.tasks.push({
				data: data,
				callback: callback
			});
			setTimeout(function(){
				q.process();
			}, 0);
		},
		dequeue: function(){
			if(currentCallback){
				currentCallback();
			}else{
				q.running = false;
			}
		},
		process: function(){
			if(q.tasks.length && !q.running){
				var task = q.tasks.shift();
				q.running = true;
				currentCallback = function(){
					q.running = false;
					task.callback(task.data);
					q.process();
				};
				currentData = task.data;
				worker(task.data, currentCallback);
			}
		}
	}
	return q;
};
}, {
    map:globalMap
});
})();(function(){
function mix(a,b){for(var k in b){a[k]=b[k];}return a;}
var _0 = "dpapp-share@~0.1.0";
var _1 = "dpapp@1.4.12/lib/core.js";
var _2 = "dpapp@1.4.12/lib/util.js";
var _3 = "dpapp@1.4.12/lib/errortrace.js";
var _4 = "dpapp@1.4.12/lib/apis.js";
var _5 = "dpapp@1.4.12/lib/web.js";
var _6 = "dpapp@1.4.12/lib/type.js";
var _7 = "dpapp@1.4.12/lib/version.js";
var _8 = "dpapp@1.4.12/lib/patch/patch-7.1.0.js";
var _9 = "dpapp@1.4.12/lib/patch/patch-7.0.0.js";
var _10 = "dpapp@1.4.12/lib/patch/patch-7.2.0.js";
var _11 = "dpapp@1.4.12/lib/patch/patch-7.5.0.js";
var _12 = "dpapp@1.4.12/lib/patch/patch-7.6.0.js";
var _13 = "dpapp@1.4.12/lib/patch/patch-7.9.1.js";
var _14 = "dpapp@1.4.12/lib/patch/patch-7.8.0.js";
var _15 = "dpapp@1.4.12/lib/patch/patch-7.9.2.js";
var _16 = "dpapp@1.4.12/lib/patch/patch-7.9.4.js";
var _17 = "dpapp@1.4.12/lib/patch/patch-7.9.6.js";
var _18 = "dpapp@1.4.12/lib/patch/patch-8.0.0.js";
var _19 = "dpapp@1.4.12/lib/patch/patch-8.0.4.js";
var _20 = "dpapp@1.4.12/lib/patch/patch-8.0.6.js";
var _21 = "dpapp@1.4.12/lib/patch/patch-8.1.0.js";
var _22 = "dpapp@1.4.12/lib/patch/patch-8.1.2.js";
var _23 = "dpapp@1.4.12/lib/patch/patch-8.1.4.js";
var _24 = "dpapp@1.4.12/lib/patch/patch-8.1.6.js";
var _25 = "dpapp-core@^1.1.1";
var _26 = "mix@^1.0.1";
var _27 = "dpapp@1.4.12/lib/async.js";
var _28 = "dpapp@1.4.12/index.js";
var asyncDeps = [_0];
var asyncDepsToMix = {"dpapp-share":_0};
var globalMap = asyncDepsToMix;
define(_28, [_1,_2,_3,_4,_5,_6,_7,_8,_9,_10,_11,_12,_13,_14,_15,_16,_17,_18,_19,_20,_21,_22,_23,_24], function(require, exports, module, __filename, __dirname) {
'use strict';
(function (Host) {
  var core = require('./lib/core');
  var util = require('./lib/util');
  var apis = require('./lib/apis');

  require('./lib/errortrace');
  
  var patchVersion = function(version, patch) {
    if (core.Semver.gte(util.appVersion, version)) {
        core.patchForType(util.appVersion, patch);
    }
  };

  patchVersion('7.0.0', require('./lib/patch/patch-7.0.0'));
  patchVersion('7.1.0', require('./lib/patch/patch-7.1.0'));
  patchVersion('7.2.0', require('./lib/patch/patch-7.2.0'));
  patchVersion('7.5.0', require('./lib/patch/patch-7.5.0'));
  patchVersion('7.6.0', require('./lib/patch/patch-7.6.0'));
  patchVersion('7.8.0', require('./lib/patch/patch-7.8.0'));
  patchVersion('7.9.1', require('./lib/patch/patch-7.9.1'));
  patchVersion('7.9.2', require('./lib/patch/patch-7.9.2'));
  patchVersion('7.9.4', require('./lib/patch/patch-7.9.4'));
  patchVersion('7.9.6', require('./lib/patch/patch-7.9.6'));
  patchVersion('8.0.0', require('./lib/patch/patch-8.0.0'));
  patchVersion('8.0.4', require('./lib/patch/patch-8.0.4'));
  patchVersion('8.0.6', require('./lib/patch/patch-8.0.6'));
  patchVersion('8.1.0', require('./lib/patch/patch-8.1.0'));
  patchVersion('8.1.2', require('./lib/patch/patch-8.1.2'));
  patchVersion('8.1.4', require('./lib/patch/patch-8.1.4'));
  patchVersion('8.1.6', require('./lib/patch/patch-8.1.6'));

  patchVersion('web', require('./lib/web'));

  core.apis = apis;
  core.decorate();

  apis.forEach(function (api) {
    if (!core[api]) {
      core[api] = core._notImplemented;
    }
  });

  core.__version__ = require('./lib/version');
  core.__type__ = require('./lib/type');
  // Export DPApp object, if support AMD, CMD, CommonJS.
  if (typeof module !== 'undefined') {
    module.exports = core;
  }
  // Export DPApp object to Host
  if (typeof Host !== 'undefined') {
    if(Host.DPApp){
      core.merge(Host.DPApp, core);
    }else{
      Host.DPApp = core;
    }
  }

}(window));
}, {
    asyncDeps:asyncDeps,
    main:true,
    map:mix({"./lib/core":_1,"./lib/util":_2,"./lib/errortrace":_3,"./lib/apis":_4,"./lib/web":_5,"./lib/type":_6,"./lib/version":_7,"./lib/patch/patch-7.1.0":_8,"./lib/patch/patch-7.0.0":_9,"./lib/patch/patch-7.2.0":_10,"./lib/patch/patch-7.5.0":_11,"./lib/patch/patch-7.6.0":_12,"./lib/patch/patch-7.9.1":_13,"./lib/patch/patch-7.8.0":_14,"./lib/patch/patch-7.9.2":_15,"./lib/patch/patch-7.9.4":_16,"./lib/patch/patch-7.9.6":_17,"./lib/patch/patch-8.0.0":_18,"./lib/patch/patch-8.0.4":_19,"./lib/patch/patch-8.0.6":_20,"./lib/patch/patch-8.1.0":_21,"./lib/patch/patch-8.1.2":_22,"./lib/patch/patch-8.1.4":_23,"./lib/patch/patch-8.1.6":_24},globalMap)
});

define(_1, [_25,_26,_2], function(require, exports, module, __filename, __dirname) {
'use strict';
var Core = require('dpapp-core');
var mixin = require('mix');
var util = require('./util');

var NOOP = function(){};

var core = module.exports = new Core({
  hippoPrefix:'dpapp',
  getTypeFromUA: util.getWebviewVersion,
  apis: [],
  allowBeforeReady: ['getRequestId'],
  isOldVersion: function(){
    return this.uaType() == '6.9.x';
  },
  cache: {},
  Share: {
    WECHAT_FRIENDS: 0,
    WECHAT_TIMELINE: 1,
    QQ: 2,
    SMS: 3,
    WEIBO: 4,
    QZONE: 5,
    EMAIL: 6,
    COPY: 7
  },
  _tidyUrlParams: function(url){
    var splited = url.split('?');
    var qs = splited[1];
    var reserved = [];
    if(!qs){
      return splited[0];
    }else{
      qs.split('&').forEach(function(q){
        var k = q.split('=')[0];
        if(!/^(newtoken|token)$/.test(k)){
          reserved.push(q);
        }
      });
      return [splited[0], reserved.join('&')].join('?');
    }
  },
  _getEnv : function(callback) {
    var self = this;
    this._doSendMessage('getEnv', {}, function(env){
      self.cache['env'] = env;
      callback.call(this, env);
    });
  },
  _captal: function(str) {
    return str.slice(0, 1).toUpperCase() + str.slice(1);
  },
  _getBizName: function(opt) {
    var fail = opt.fail;
    var bizname = this._cfg.bizname;
    if (!bizname) {
      fail && fail('use `DPApp.config({bizname:"<your-bizname>"})` first');
      return false;
    } else {
      return bizname;
    }
  },
  isStatusOK : NOOP,
  did_handle_callback : NOOP, 
  _doSendMessage: function (method, args, callback) {
    var self = this;
    var hasCallback = callback && typeof callback == 'function';
    this.log('调用方法', method, args);

    /**
     * pass 0 as callbackId
     * thus _callbacks[callbackId] is undefined
     * nothing will happen
     * @type {Number}
     */
    var callbackId = hasCallback ? this._generateCallbackId() : 0;
    var callbackName = this._generateCallbackName(callbackId);
    
    if (hasCallback){
      window[callbackName] = callback;
    }

    /**
     * check type for args
     */
    if(!args || typeof args !== 'object'){
      args = {};
    }

    // 某些版本app很任性的把callbackId参数放到args里了
    args.callbackId = callbackId;
    args = JSON.stringify(args);

    var _DPApp = window._DPApp;

    var bridgeUrl = 'js://_?method=' + method + '&args=' + encodeURIComponent(args) + '&callbackId=' + callbackId;
    
    this._sendMessage2Native(bridgeUrl); 
  },
  _sendByPrompt: function(message) {
    this.log('[Prompt] message: ' +message);
    window.prompt(message);
  },
  _sendByIframe: function(message) {
    this.log('[Iframe] message: ' + message);
    this._createIframe(message);
  },
  _sendMessage2Native: function(message) {
    var SUPPORTVERSION = '8.0.6';
    if (this.Semver.gte(util.appVersion, SUPPORTVERSION) && util.osName === 'android') {
      this._sendByPrompt(message);
    }else{
      this._sendByIframe(message);
    }
  },
  _send: function(method, args){
    args = args || {};
    var self = this;
    var _success = args.success;
    var _fail = args.fail;
    var _handle = args.handle;

    var fail = function(result){
      self.log('调用失败 ' + method, result);
      _fail && _fail.call(self, result);
    }

    var success = function(result){
      self.log('调用成功 ' + method, result);
      _success && _success.call(self, result);
    }

    var handle = function(result){
      self.log('回调 ' + method, result);
      _handle && _handle.call(self, result);
    }

    var callback = (_success || _fail || _handle) ? function(result){
      var status = result.status;

      if(result.result != "next"){
        delete result.result;
      }
      if(status == "success"){
        success && success(result);
      }else if(status == "action"){
        handle && handle(result);
      }else{
        fail && fail(result);
      }
    } : null;
    this._sendMessage(method, args, callback);
  },
  callback: function(callbackId, retValue){
    var win = window;
    var callbackFuncName = this._generateCallbackName(callbackId);
    var callback = window[callbackFuncName];

    if(callback){
      this.log("[Callback] Id: " + callbackId);
      setTimeout(function(){
        callback && callback.call(self,retValue);
      });
      if(retValue.result == "complete" || retValue.result == "error"){
        win[callbackFuncName] = null;
        delete win[callbackFuncName];
      }
    }
  },
  merge: function(core, newCore) {
    if (core.__type__ === 'npm' || core.__type__ === 'cortex') {
      console.warn('引入了多个DPApp,目前DPApp版本是',core.__version__,', 后续引入的DPApp无法生效');
      return;
    }else{
      mixin(core,newCore);
      console.warn('引入了多个DPApp,正在进行mixin形式的合并');
    }
  }
});
}, {
    asyncDeps:asyncDeps,
    map:mix({"./util":_2},globalMap)
});

define(_2, [], function(require, exports, module, __filename, __dirname) {
'use strict';

var regexVer = /dp\/com\.dianping\.[\w\.]+\/([\d\.]+)/;

var getAppVersion = function (ua) {
  var version;
  var regexMAPI = /MApi/;
  var match  = ua.match(regexVer);
  if (match) {
    version = match[1];
  }else if (regexMAPI.test(ua)) {
    version = '7.0.0';
  }else{
    version = 'web';
  }
  return version;
};
var getOSName = function (ua) {
  var regexAndroid = /android/i;
  var regexIos = /ipad|iphone/i;
  if (regexAndroid.test(ua)) {
    return 'android';
  }else if (regexIos.test(ua)) {
    return 'ios';
  }
};

var getAdapterVersion = function (ua) {
  if (ua.match(regexVer)) {
    var reg = /adapter\/([\d\.]+)/;
    var match = ua.match(reg);
    if (match) {
      return match[1];
    }
  }
};

var getWebviewVersion = function(ua) {
  return getAdapterVersion(ua) || getAppVersion(ua);
};

var appVersion = getAppVersion(navigator.userAgent);
var osName = getOSName(navigator.userAgent);

module.exports = {
  appVersion: appVersion,
  getAppVersion: getAppVersion,
  osName: osName,
  getOSName: getOSName,
  getWebviewVersion: getWebviewVersion,
  actionMapping: function (method) {
    return function (opt) {
      this._send(method, opt);
    };
  }
};
}, {
    asyncDeps:asyncDeps,
    map:globalMap
});

define(_3, [], function(require, exports, module, __filename, __dirname) {
'use strict';

var _err = window.onerror;
var url = 'http://catdot.dianping.com/broker-service/api/js';
window.onerror = function(err, file, line, col, error){
  var e = encodeURIComponent;
  var time = Date.now();
  (new window.Image).src = url
    + '?error=' + e(err)
    + '&v=1'
    + '&data=' + e(error && error.stack ? error.stack : '')
    + '&url=' + e(location.href)
    + '&file=' + e(file)
    + '&line=' + e(line)
    + '&col=' + e(col)
    + '&timestamp=' + time;
  _err && _err(err, file, line, col, error);
};
}, {
    asyncDeps:asyncDeps,
    map:globalMap
});

define(_4, [], function(require, exports, module, __filename, __dirname) {
module.exports = [
  /*
  * Common
  */
  "getRequestId", 
  "isInstalledApp",
  /*
  * DeviceInfo
  */
  "getNetworkType", 
  "getVersion",
  /*
  * UserInfos
  */
  "getUserInfo", 
  "login", 
  "updateAccount", 
  "logout",
  "thirdLogin",
  /*
  * GeoInfos
  */ 
  "getCityId", 
  "getLocation", 
  "getCity",
  /*
  * Common business
  */
  "setPullDown", 
  "stopPullDown", 
  "openScheme", 
  "jumpToScheme", 
  "closeWindow", 
  "getContactList", 
  "sendSMS", 
  "bindPhone",
  "ajax", 
  "setSpotlight",
  "getHealthData",
  "pickCity",
  "analyticsTag",
  /*
  * Storage
  */
  "store", 
  "retrieve",
  /*
  *  Picture
  */
  "downloadImage", 
  "chooseImage", 
  "previewImage",
  "uploadImage",
  /*
  * Audio
  */
  "playVoice",
  /*
  * Share
  */
  "share",
  /*
  * Broadcast
  */
  "publish", 
  "subscribe", 
  "unsubscribe", 

  /*
  * System widget
  */
  "alert", 
  "prompt", 
  "confirm", 
  "actionSheet", 
  /*
  * System UI
  */
  "setTitle", 
  "setBackgroundColor", 
  "setNavigationBarHidden", 
  "setScrollEnabled",
  "setLLButton", 
  "setLRButton", 
  "setRLButton", 
  "setRRButton", 
  "setBouncesEnabled",
  "setStatusBarStyle",
  /*
    Other
   */
  "setBarrageEnabled",
  /*
  * Private
  */
  "getCX",
  "pay"
];
}, {
    asyncDeps:asyncDeps,
    map:globalMap
});

define(_5, [_26,_4], function(require, exports, module, __filename, __dirname) {
'use strict';
var mixin = require('mix');
var apis = require('./apis');
var web = {};

var EVENT_VISIBILITY_CHANGE = 'webkitvisibilitychange';
var EVENT_SCROLL = 'scroll';

/**
 * Common
 * 基础功能，所有app都会用到
 */
mixin(web, {
  version: 'web',
  getUA: function(opt) {
    var success = opt && opt.success;
    var ua = {
      platform: 'web',
      appName: null,
      appVersion: null,
      osName: this._osUA.name,
      osVersion: this._osUA.version
    };
    success && success(ua);
    return ua;
  },
  ready: function(fn) {
    var self = this;
    var readyRE = /complete|loaded|interactive/;
    if (readyRE.test(document.readyState) && document.body) {
      self._isReady = true;
      fn();
    } else {
      document.addEventListener('DOMContentLoaded', function() {
        self._isReady = true;
        fn();
      }, false);
    }
  },
  ajax: function(opts) {
    var METHOD_GET = 'GET';
    var url = opts.url;
    var method = (opts.method || METHOD_GET).toUpperCase();
    var headers = opts.headers || {};
    var data = opts.data;
    var success = opts.success;
    var fail = opts.fail;

    var xhr = new XMLHttpRequest();

    if (!url) {
      url = location.href.split('?')[0];
    }

    if (method === METHOD_GET && data) {
      url += parseQuery(data);
      data = null;
    }

    if (method !== METHOD_GET) {
      xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    }

    function parseQuery(data) {
      var queryString = '';
      for (var key in data) {
        queryString += key + '=' + encodeURIComponent(data[key]);
      }
      return queryString;
    }

    xhr.onreadystatechange = function() {
      if (xhr.readyState == 4) { // ready
        xhr.onreadystatechange = function() {};
        var result, error = false;
        if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
          result = xhr.responseText;

          try {
            result = /^\s*$/.test(result) ? null : JSON.parse(result);
          } catch (e) {
            error = e;
          }

          if (error) fail && fail('ERR_PARSE_JSON');
          else success(result);
        } else {
          fail && fail(xhr.statusText);
        }
      }
    };

    xhr.open(opts.method, url, true, opts.username, opts.password);
    for (var name in headers) {
      xhr.setRequestHeader(name, headers[name]);
    }
    xhr.send(data);
  },
  closeWindow: function() {
    window.close();
  }
});

/**
 * Infos
 */
mixin(web, {
  getLocation: function(opts) {
    var success = opts.success;
    var fail = opts.fail;
    navigator.geolocation.getCurrentPosition(function(position) {
      success && success({
        lat: position.coords.latitude,
        lng: position.coords.longitude
      });
    }, function() {
      fail && fail('ERR_GET_LOCATION');
    });
  },
  getCityId: function(opt) {
    var result;
    var getCookie = function(name) {
      if (!result) {
        result = {};
        document.cookie.split(';').forEach(function(p) {
          var c = p.trim().split('=');
          var name = c[0];
          var value = c[1];
          result[name] = value;
        });
      }
      return result[name];
    };

    var cityId = getCookie('cy') || getCookie('cityid');
    if (!cityId) {
      cityId = null;
    }

    opt && opt.success && opt.success({
      cityId: cityId
    });
  },
  getCity: function (opt) {
    return this.getCityId(opt);
  }
});

/**
 * Funcs
 */
mixin(web, {
  share: function(opts) {
    var success = opts.success;

    var title = opts.title;
    var desc = opts.desc;
    var content = opts.content;
    var pic = opts.image;
    var url = opts.url;

    require.async('dpapp-share', function(share) {
      share.pop({
        title: title,
        desc: desc,
        content: content,
        pic: pic,
        url: url
      });
      success && success();
    });
  }
});

/**
 * UI
 */
mixin(web, {
  setTitle: function(opts) {
    var title = opts.title;
    if (title) {
      document.title = title;
    }
    opts.success && opts.success();
  }
});


/**
 * Broadcast
 */
var _events = {};
mixin(web, {
  subscribe: function(opts) {
    var self = this;
    var name = opts.action;
    var success = opts.success;
    var handle = opts.handle;
    var fail = opts.fail;
    if (!name || !handle) {
      fail && fail('missing params');
      return;
    }
    if (_events[name]) {
      _events[name].push(handle);
    } else {
      _events[name] = [handle];
    }

    if (name == EVENT_SCROLL) {
      window.addEventListener(EVENT_SCROLL, self._scrollEvent);
    }
    if (name == 'appear') {
      document.addEventListener(EVENT_VISIBILITY_CHANGE, self._appearEvent);
    }

    if (name == 'disappear') {
      document.addEventListener(EVENT_VISIBILITY_CHANGE, self._disappearEvent);
    }

    success && success();
  },
  _appearEvent: function() {
    if (document.hidden == false) {
      DPApp.publish({
        action: 'appear'
      });
    }
  },
  _disappearEvent: function() {
    if (document.hidden == true) {
      DPApp.publish({
        action: 'disappear'
      });
    }
  },
  _scrollEvent: function() {
    DPApp.publish({
      action: EVENT_SCROLL,
      data: {
        offset: window.scrollY
      }
    });
  },
  unsubscribe: function(opts) {
    var self = this;
    var name = opts.action;
    var success = opts.success;
    var handle = opts.handle;
    var fail = opts.fail;
    if (!name) {
      fail && fail('Missing params');
      return;
    }
    var events = _events;
    var funcs = events[name];
    if (!funcs) {
      success && success();
      return;
    }
    if (handle) {
      var index = funcs.indexOf(handle);
      events[name] = funcs.splice(index, 1);
    } else {
      if (name == EVENT_SCROLL) {
        window.removeEventListener(EVENT_SCROLL, self._scrollEvent);
      }
      delete events[name];
    }
    success && success();
  },
  openScheme: function(opts) {
    var iframe = document.createElement('iframe');
    var extra = opts.extra;
    var url = opts.url;
    if (extra) {
      url += '?' + this._convertUrlParams(extra);
      delete opts.extra;
    }
    iframe.style.display = 'none';
    iframe.src = url;
    document.body.appendChild(iframe);
  },
  publish: function(opts) {
    if (!opts.action) {
      return;
    }
    var name = opts.action;
    var data = opts.data;
    var success = opts.success;
    var funcs = _events[name];
    funcs && funcs.forEach(function(func) {
      func(data);
    });
    success && success();
  }
});

var mock = document.cookie.match(/dpapp-mocker=(\w+)/);
if (mock) {
  mock = mock[1];
}

var jsonp_callback_id = 1;

function jsonp(name) {
  return function(opts) {
    var params = JSON.stringify(opts);
    var success = opts.success;
    var fail = opts.fail;
    var handle = opts.handle;
    var script = document.createElement('script');
    var funcName = 'jsonp_callback' + jsonp_callback_id;
    jsonp_callback_id++;
    script.src = 'http://localhost:1943/?' + 'method=' + name + '&params=' + encodeURIComponent(params) + '&callback=' + funcName;

    window[funcName] = function(result) {
      var status = result.status;
      if (status == 'success') {
        success && success(result);
      } else if (status == 'action') {
        handle && handle(result);
      } else {
        fail && fail(result);
      }
    };
    document.body.appendChild(script);
  };
}

apis.forEach(function(name) {
  if (mock == 'force') {
    web[name] = jsonp(name);
  } else if (!web.hasOwnProperty(name)) {
    if (mock == 'patch') {
      web[name] = jsonp(name);
    }
  }
});

module.exports = web;
}, {
    asyncDeps:asyncDeps,
    map:mix({"./apis":_4},globalMap)
});

define(_6, [], function(require, exports, module, __filename, __dirname) {
module.exports = ("cortex");
}, {
    asyncDeps:asyncDeps,
    map:globalMap
});

define(_7, [], function(require, exports, module, __filename, __dirname) {
module.exports = ("1.4.12");
}, {
    asyncDeps:asyncDeps,
    map:globalMap
});

define(_8, [_2,_1,_9], function(require, exports, module, __filename, __dirname) {
'use strict';
var util = require('../util');
var core = require('../core');
var patch7  = require('./patch-7.0.0');

//更新的API: share, initShare, closeWindow, _parseFeed
//新增的API: setTitle等
var newAPIs = [
    'setLLButton', 
    'setLRButton', 
    'setRLButton', 
    'setRRButton',
    'setTitle',
    'sendSMS',
    'publish',
    'closeWindow'
  ];

var _events = {};
var pageEvents = ['appear', 'disappear', 'scroll'];
function getPageMethodName(name) {
  var result = 'on' + core._captal(name);
  // fix for android 7.6.0
  if (util.osName == 'android' && util.appVersion == '7.6.0' && /appear|disappear/.test(name)) {
    result = name;
  }
  return result;
}

var getUA = (function() {
  var uastr = navigator.userAgent;
  var appVersionMatch = uastr.match(/dp\/[\w\.\d]+\/([\d\.]+)/);
  var appVersion = appVersionMatch && appVersionMatch[1];
  var matchPackageId = uastr.match(/dp\/(com\.dianping\.\w+)/);
  var packageId = matchPackageId && matchPackageId[1];
  var adapterMatch = uastr.match(/adapter\/([\d\.]+)/);
  var adapterVersion = adapterMatch && adapterMatch[1];

  return function(opt) {
    var success = opt && opt.success;
    var ua = {
      platform: 'dpapp',
      appName: 'dianping',
      packageId: packageId,
      appVersion: appVersion,
      osName: core._osUA.name,
      osVersion: core._osUA.version,
      adapterVersion: adapterVersion
    };
    success && success(ua);
    return ua;
  };
})();

var Patch = module.exports = {
  appVersion: '7.1.0',
  pay: patch7.pay,
  
  uploadImage: patch7.uploadImage,
  
  getUA: getUA,

  ready: function(callback) {
    var self = this;
    this._send('ready', {
      success: function() {
        self._isReady = true;
        callback();
      }
    });
  },

  login: function(opt) {
    var self = this;
    var loginUser;

    function getUser(callback) {
      self.getUserInfo({
        success: callback
      });
    }
    getUser(function(result) {
      if (result.token) {
        opt.success && opt.success(result);
      } else {
        var loginEvent = 'loginSuccess';
        var appearEvent = 'appear';

        var loginSuccessHandler = function() {
          getUser(function (user) {
            loginUser = user;
          });
          self.unsubscribe({
            action: loginEvent,
            handle: loginSuccessHandler
          });
        };

        self.subscribe({
          action: loginEvent,
          handle: loginSuccessHandler
        });

        var appearHandler = function () {
          getUser(function (user) {
            if (user && user.token) {
              opt.success && opt.success(user);
            }else{
              opt.fail && opt.fail(user);
            }
            
          });
          self.unsubscribe({
            action: appearEvent,
            handle: appearHandler
          });
        };

        self.subscribe({
          action: appearEvent,
          handle: appearHandler
        }); 

        self.openScheme({
          url: 'dianping://login'
        });
      }
    });
  },
  updateAccount: function(opt) {
    opt = opt || {};
    var self = this;
    var dper = document.cookie.match(/dper=\w+/);
    if (dper) {
      dper = dper[0].split('=')[1];
    }

    if (opt.dper) {
      dper = opt.dper;
    }

    if (!dper) {
      return opt.fail && opt.fail('Missing dper');
    }
    var _loopGetUserInfo = function(success, fail) {
      var retries = 0;
      function loopGetUserInfo() {
        self.getUserInfo({
          success: function(info) {
            if (info.token) {
              success && success(info);
            } else {
              if (retries > 5) {
                fail && fail();
              } else {
                retries++;
                setTimeout(function() {
                  loopGetUserInfo();
                }, 100);
              }
            }
          }
        });
      }
      loopGetUserInfo();
    };

    self.ajax({
      url: 'http://m.api.dianping.com/mlogin/convertdper.api',
      data: {
        dper: dper
      },
      keys: ['Token', 'NewToken'],
      success: function(result) {
        var ua = self.getUA();
        if (self.Semver.gte(ua.appVersion, '7.5.0')) {
          self._send('updateAccount', {
            token: result.Token,
            newtoken: result.NewToken,
            success: function() {
              self.getUserInfo({
                success: opt.success
              });
            },
            fail: opt.fail
          });
        } else {
          self._send('loginsuccess', {
            token: result.Token,
            newtoken: result.NewToken
          });

          _loopGetUserInfo(opt.success, opt.fail);
        }
      },
      fail: opt.fail
    });
  },
  _parseFeed: function(f){
    var feed;
    if (!f) {
      return 0xff;
    } else if (f.constructor.toString().indexOf('Array') >= 0) {
      feed = [0, 0, 0, 0, 0, 0, 0, 0];
      f.forEach(function(pos) {
        feed[7 - pos] = 1;
      });
      return parseInt(feed.join(''), 2);
    }
  },
  share: function(opt) {
    opt.feed = this._parseFeed(opt.feed);
    opt.url = this._tidyUrlParams(opt.url);
    this._send('share', opt);
  },
  initShare: function(opt) {
    var self = this;
    this.setRRButton({
      icon: 'H5_Share',
      handle: function() {
        opt.handle && opt.handle();
        self.share({
          title: opt.title,
          desc: opt.desc,
          content: opt.content,
          image: opt.image,
          feed: opt.feed,
          url: opt.url,
          success: opt.success,
          fail: opt.fail
        });
      }
    });
  },
  subscribe: function(opt) {
    var name = opt.action;
    var handle = opt.handle;

    function mainHandler(e) {
      _events[name] && _events[name].length && _events[name].forEach(function(func) {
        func && func(e);
      });
    }

    if (_events[name]) {
      opt.success && opt.success();
      _events[name].push(handle);
    } else {
      this._send('subscribe', {
        action: name,
        success: opt.success,
        handle: mainHandler
      });

      _events[name] = [handle];
    }
  },

  unsubscribe: function(opt) {
    var name = opt.action;
    var success = opt.success;
    var handle = opt.handle;

    var index = _events[name] ? _events[name].indexOf(handle) : -1;

    if (index != -1) {
      _events[name].splice(index, 1);
      success && success();
      if (!_events[name].length) {
        _events[name] = null;
      }
    } else if (!handle) {
      _events[name] = null;
    }

    if (!_events[name]) {
      this._send('unsubscribe', {
        action: name,
        success: success
      });
    }
  },

  openScheme: function(opt) {
    var url = opt.url;
    var extra = opt.extra;
    if (extra) {
      url += '?' + this._convertUrlParams(extra);
      delete opt.extra;
      opt.url = url;
    }
    this._send('openScheme', opt);
  }
};

newAPIs.forEach(function (api) {
  Patch[api] = util.actionMapping(api);
});

pageEvents.forEach(function(name) {
  Patch[getPageMethodName(name)] = function (){};
});
}, {
    asyncDeps:asyncDeps,
    map:mix({"../util":_2,"../core":_1,"./patch-7.0.0":_9},globalMap)
});

define(_9, [_2], function(require, exports, module, __filename, __dirname) {
'use strict';
var util = require('../util');

module.exports = {
  appVersion: '7.0',
  _parseFeed: function(f){
    var feed;
    if (!f) {
      return 0xff;
    } else if (f.constructor.toString().indexOf('Array') >= 0) {
      feed = [0, 0, 0, 0, 0, 0, 0, 0];
      f.forEach(function(pos) {
        feed[pos] = 1;
      });
      return parseInt(feed.join(''), 2);
    }
  },
  share : function(opts){
    opts.feed = this._parseFeed(opts.feed);
    opts.url = this._tidyUrlParams(opts.url);
    this._sendMessage('share', opts);
  },
  initShare: function(opt){
    var success = opt.success;
    var fail = opt.fail;
    var src = 'dpshare://_?content=';
    src += encodeURIComponent(JSON.stringify({
      title: opt.title,
      desc: opt.desc,
      image: opt.image,
      feed: this._parseFeed(opt.feed),
      url: opt.url
    }));
    this.shareCallback = function(result){
      if(result.status == 'success'){
        success && success(result);
      }else{
        fail && fail(result);
      }
    };
    this._createIframe(src);
  },
  getUA: function(opt) {
    var success = opt && opt.success;
    var appVersion = navigator.userAgent.match(/MApi\s[\w\.]+\s\([\w\.\d]+\s([\d\.]+)/)[1];
    var ua = {
      platform: 'dpapp',
      appName: 'dianping',
      appVersion: appVersion,
      osName: this._osUA.name,
      osVersion: this._osUA.version
    };
    success && success(ua);
    return ua;
  },
  ready: function(callback) {
    this._isReady = true;
    callback();
  },
  pay: function(args) {
    var self = this;
    var payType = args.payType;
    var success = args.success;
    var fail = args.fail;
    var cx = args.cx;

    function payOrder(data, callback) {
      DPApp.ajax({
        url: 'http://api.p.dianping.com/payorder.pay',
        data: data,
        keys: ['Content'],
        success: function(paymsg) {
          callback(null, paymsg);
        },
        fail: function() {
          callback('fail payorder');
        }
      });
    }

    function getPaymentTool(payType) {
      var PAY_TYPE_MINIALIPAY = 1;
      var PAY_TYPE_WEIXINPAY = 7;
      var PAYMENTTOOL_ALIPAY = '5:1:null#219#0';
      var PAYMENTTOOL_WEIXINPAY = '11:1:null#217#0';
      if (payType == PAY_TYPE_WEIXINPAY) {
        paymentTool = PAYMENTTOOL_WEIXINPAY;
      } else {
        paymentTool = PAYMENTTOOL_ALIPAY;
      }
      return paymentTool;
    }

    payOrder({
      token: args.token,
      orderid: args.orderId,
      paymenttool: getPaymentTool(payType),
      cx: cx
    }, function(err, paymsg) {
      if (err) {
        return fail && fail(err);
      }

      self._sendMessage('pay', {
        paytype: payType,
        paycontent: paymsg.Content
      }, function(data) {
        if (data.payresult) {
          success && success(data);
        } else {
          fail && fail(data);
        }
      });
    });
  },
  uploadImage: function(opts) {
    var fail = opts.fail;
    var handle = opts.handle;

    this._sendMessage('uploadImage', opts, function(result) {
      var status = result.status;
      if (status == 'fail') {
        fail && fail(result);
        return;
      } else {
        handle && handle(result);
      }
    });
  },
  ajax: function(args) {
    args = this._sanitizeAjaxOpts(args);
    var _success = args.success;
    args.success = function(e) {
      var result = JSON.parse(e.mapiResult);
      result = this._transModel(args.keys, result);
      _success(result);
    };

    this._send('mapi', args);
  },
  getCX: util.actionMapping('getCX'),
  getContactList: util.actionMapping('getContactList'),
  getRequestId: util.actionMapping('getRequestId'),
  closeWindow: util.actionMapping('close_web'),
  getUserInfo: util.actionMapping('getUserInfo'),
  getCity: util.actionMapping('getCityId'),
  getCityId: util.actionMapping('getCityId'),
  getLocation: util.actionMapping('getLocation')
};
}, {
    asyncDeps:asyncDeps,
    map:mix({"../util":_2},globalMap)
});

define(_10, [], function(require, exports, module, __filename, __dirname) {
'use strict';

module.exports = {
  appVersion: '7.2.0',

  jumpToScheme: function(opt) {
    var url = opt.url;
    var extra = opt.extra;
    if (extra) {
      url += '?' + this._convertUrlParams(extra);
      delete opt.extra;
      opt.url = url;
    }
    opt.toHome = !!opt.toHome ? 1 : 0;
    this._send('jumpToScheme', opt);
  },
  publish: function(opt) {
    var bizname = this._getBizName(opt);
    var CONSTS = ['phoneChanged', 'AccountBindChange'];
    if (bizname) {
      if (CONSTS.indexOf(opt.action) == -1) {
        opt.action = bizname + ':' + opt.action;
      }
      this._send('publish', opt);
    }
  }
};
}, {
    asyncDeps:asyncDeps,
    map:globalMap
});

define(_11, [_2], function(require, exports, module, __filename, __dirname) {
'use strict';
var util = require('../util');

module.exports = {
  appVersion: '7.5.0',
  
  store: function(opt) {
    var bizname = this._getBizName(opt);
    if (bizname) {
      opt.key = bizname + ':' + opt.key;
      this._send('store', opt);
    }
  },
  retrieve: function(opt) {
    var bizname = this._getBizName(opt);
    if (opt.key.indexOf(':') === -1) {
      opt.key = bizname + ':' + opt.key;
    }
    this._send('retrieve', opt);
  },
  setBackgroundColor: util.actionMapping('setBackgroundColor')
};
}, {
    asyncDeps:asyncDeps,
    map:mix({"../util":_2},globalMap)
});

define(_12, [_1,_2], function(require, exports, module, __filename, __dirname) {
'use strict';
var util = require('../util');
var core = require('../core');

var _events = {};
var pageEvents = ['appear', 'disappear', 'scroll'];
function getPageMethodName(name) {
  var result = 'on' + core._captal(name);
  // fix for android 7.6.0
  if (util.osName == 'android' && util.appVersion == '7.6.0' && /appear|disappear/.test(name)) {
    result = name;
  }
  return result;
}

module.exports = {
  appVersion: '7.6.0',
  
  isInstalledApp: util.actionMapping('isInstalledApp'),

  subscribe: function(opt) {
    var self = this;
    var name = opt.action;
    var handle = opt.handle;
    var messageName;

    function mainHandler(e) {
      _events[name] && _events[name].length && _events[name].forEach(function(func) {
        func && func(e);
      });
    }

    function registerPageEvents() {
      if (messageName) {
        window.DPApp && (window.DPApp[getPageMethodName(name)] = mainHandler);
        opt.success && opt.success();
      }
    }

    if (_events[name]) {
      opt.success && opt.success();
      _events[name].push(handle);
    } else {
      if (pageEvents.indexOf(name) !== -1) {
        messageName = 'on' + self._captal(name);
        if (name == 'scroll') {
          // 仅scroll事件需要toggle开关
          this._send(messageName, {
            success: registerPageEvents
          });
        } else {
          // 不然就直接注册上了
          registerPageEvents();
        }
      } else {
        this._send('subscribe', {
          action: name,
          success: opt.success,
          handle: mainHandler
        });
      }

      _events[name] = [handle];
    }
  },

  unsubscribe: function(opt) {
    var name = opt.action;
    var success = opt.success;
    var handle = opt.handle;
    var self = this;

    var index = _events[name] ? _events[name].indexOf(handle) : -1;

    function unregisterPageEvents() {
      self[callbackName] = function () {};
    }

    if (index != -1) {
      _events[name].splice(index, 1);
      success && success();
      if (!_events[name].length) {
        _events[name] = null;
      }
    } else if (!handle) {
      _events[name] = null;
    }

    if (!_events[name]) {
      // unregister
      // if is page event
      if (pageEvents.indexOf(name) !== -1) {
        var messageName = 'off' + self._captal(name);
        var callbackName = 'on' + self._captal(name);
        // 与安卓确认
        if (name == 'scroll') {
          this._send(messageName, {
            success: unregisterPageEvents
          });
        } else {
          unregisterPageEvents();
        }
      } else {
        this._send('unsubscribe', {
          action: name,
          success: success
        });
      }
    }
  },
};
}, {
    asyncDeps:asyncDeps,
    map:mix({"../core":_1,"../util":_2},globalMap)
});

define(_13, [_2,_27,_1], function(require, exports, module, __filename, __dirname) {
'use strict';
var util = require('../util');
var async = require('../async');
var core = require('../core');

module.exports = {
  appVersion: '7.9.1',
  
  setNavigationBarHidden: util.actionMapping('setNavigationBarHidden'),

  chooseImage: function(opt) {
    opt = opt || {};
    opt.count = (!opt.count || opt.count > 9 || opt.count < 1) ? 9 : opt.count;
    this._send('chooseImage', opt);
  },
  uploadImage: function(opts) {
    var success = opts.success;
    var fail = opts.fail;
    var handle = opts.handle;
    var ua = this.getUA();
    var self = this;
    if (opts.localId || opts.localIds) {
      if (core.Semver.gte(ua.adapterVersion || ua.appVersion, '7.9.1')) {
        if (opts.localIds) {
          (function(ids) {
            var picKeys = {};
            var photoInfos = [];
            async.mapSeries(ids, function(id, done){
              self._send('uploadPhoto', {
                localId: id,
                success: function(e){
                  picKeys[id] = e.picKey;
                  photoInfos.push({
                    localId: id,
                    picKey: e.picKey//FIX BUG, What 'picKey' mean?
                  });
                  done(null);
                },
                fail: function(e){
                  done(e);
                }
              });
            }, function(e){
              if(e){
                fail && fail(e);
              }else{
                success && success({
                  picKeys: picKeys,
                  photoInfos: photoInfos
                });
              }
            });
          })(opts.localIds);
        } else {
          this._send('uploadPhoto', opts);
        }
      } else {
        fail({
          errMsg: 'ERR_NOT_IMPLEMENTED'
        });
      }
    } else {
      this._sendMessage('uploadImage', opts, function(result) {
        var status = result.status;
        if (status == 'fail') {
          fail && fail(result);
          return;
        } else {
          handle && handle(result);
        }
      });
    }
  },
};
}, {
    asyncDeps:asyncDeps,
    map:mix({"../util":_2,"../async":_27,"../core":_1},globalMap)
});

define(_14, [_2], function(require, exports, module, __filename, __dirname) {
'use strict';
var util = require('../util');

var apis = ['alert', 'confirm', 'actionSheet', 'prompt', 'setPullDown', 'stopPullDown', 'downloadImage'];
var core = {
    appVersion: '7.8.0'
};

apis.forEach(function(api) {
    var fn = util.actionMapping(api);
    core[api] = fn;
});
core.prompt = function(opt) {
    if (!opt.placeholder) {
        opt.placeholder = '';
    }
    if (util.osName === 'ios') {
        // FIX: message参数有bug，暂时不加入filterList
        var filterList = ['title', 'placeholder', 'okButton', 'cancelButton', 'success', 'fail'];
        var optKeys = Object.keys(opt);
        for (var i = 0; i < optKeys.length; i++) {
            var key = optKeys[i];
            if (!~filterList.indexOf(key)) {
                delete opt[key];
            }
        }
    }
    this._send('prompt', opt);
};

module.exports = core;

}, {
    asyncDeps:asyncDeps,
    map:mix({"../util":_2},globalMap)
});

define(_15, [_2], function(require, exports, module, __filename, __dirname) {
'use strict';
var util = require('../util');

module.exports = {
  appVersion: '7.9.2',
  
  previewImage: util.actionMapping('previewImage')
};
}, {
    asyncDeps:asyncDeps,
    map:mix({"../util":_2},globalMap)
});

define(_16, [_2], function(require, exports, module, __filename, __dirname) {
'use strict';
var util = require('../util');

module.exports = {
  appVersion: '7.9.4',
  setSpotlight: function (opt) {
    if (!opt.webpageURL) {
      return;
    }
    if (!opt.scheme) {
      opt.scheme = 'dianping://web?url=' + encodeURIComponent(opt.webpageURL);
    }
    this._send('setSpotlight', opt);
  },
  playVoice: util.actionMapping('playVoice')
};
}, {
    asyncDeps:asyncDeps,
    map:mix({"../util":_2},globalMap)
});

define(_17, [], function(require, exports, module, __filename, __dirname) {
'use strict';

module.exports = {
  appVersion: '7.9.6',

  logout: function (opt) {
    var url;
    if (opt.type === 1) {
      url = 'dianping://me';
    }else if (opt.type === 2) {
      url = 'dianping://home';
    }
    if (url) {
      opt.success = function () {
        this.openScheme({
          url: url
        });
      };      
    }
    this._send('logout', opt);
  },
  login: function (opt) {
    var self = this;
    function getUser(callback) {
      self.getUserInfo({
        success: callback
      });
    }
    // 先强制退出登录
    this.logout({
      type: 0,
      success: function() {
        // 注册事件
        var appearEvent = 'appear';
        // FIXME: loginSuccess 然并卵: 取消登录、已登录情况下不会发此通知，正常登录回调方法处理结果比appear慢！
        // var loginEvent = 'loginSuccess';
        var appearHandler = function () {
          getUser(function (user) {
            if (user && user.token) {
              console.log('login success');
              opt.success && opt.success(user);
            }else{
              console.log('login fail');
              opt.fail && opt.fail(user);
            }
          });
          self.unsubscribe({
            action: appearEvent,
            handle: appearHandler
          });
        };

        self.subscribe({
          action: appearEvent,
          handle: appearHandler
        });

        // 打开登录页
        self.openScheme({
          url: 'dianping://login'
        });
      }
    });
  }
};
}, {
    asyncDeps:asyncDeps,
    map:globalMap
});

define(_18, [_2], function(require, exports, module, __filename, __dirname) {
'use strict';
var util = require('../util');

module.exports = {
  appVersion: '8.0.0',

  setScrollEnabled: util.actionMapping('setScrollEnabled'),
  setBouncesEnabled: util.actionMapping('setBouncesEnabled'),

  bindPhone: util.actionMapping('bindPhone'),
  pay: util.actionMapping('pay')
};
}, {
    asyncDeps:asyncDeps,
    map:mix({"../util":_2},globalMap)
});

define(_19, [_2], function(require, exports, module, __filename, __dirname) {
'use strict';
var util = require('../util');

var core = {
  appVersion: '8.0.4',
  thirdLogin: function(opt) {
    var type = opt.type;
    var url;
    switch (type){
      case 1:
        url = 'http://m.dianping.com/auth/app?ft=15&sso=true';
        break;
      case 2:
        url = 'http://m.dianping.com/auth/app?ft=6&sso=true&redir=';
        break;
      case 3:
        url = 'http://m.dianping.com/auth/app?ft=5&ssp=true&redir=';
        break;
      case 4:
        url = 'http://m.dianping.com/auth/app?ft=2&source=1&sso=true&redir=';
        break;
    }
    this.openScheme({
      url: 'dianping://loginweb?url=' + encodeURIComponent(url) + '&isFromNative=true',
    });
  },
  getCX: function(opt) {
    var success = opt.success;
    opt.success = function(res) {
      if (res.fingerprint) {
        res.cx = res.fingerprint;
      }
      success(res);
    }
    this._send('getCX', opt);
  },
  uploadImage: function(opts) {
    var success = opts.success;
    var fail = opts.fail;
    var handle = opts.handle;

    if (opts.localId || opts.localIds) {

      //兼容业务对localId单图上传的支持
      if (opts.localId) {
        opts.localIds = [opts.localId];
        delete opts.localId;
      }
      
      opts.success = function(res) {
        var obj = {};
        var _localId;
        if (res.ret) {
          res.ret.forEach(function(picItem, index) {
            picItem.localId = picItem.localId || opts.localIds[index];
            
            _localId = picItem.localId;
            obj[_localId] = picItem.picKey;
          });
          res.photoInfos = res.ret;
          delete res.ret;
        }
        res.picKeys = obj;
        success(res);
      };

      this._send('uploadPhoto', opts); 

    } else {
      this._sendMessage('uploadImage', opts, function(result) {
        var status = result.status;
        if (status == 'fail') {
          fail && fail(result);
          return;
        } else {
          handle && handle(result);
        }
      });
    }
  }
};
if (util.osName === 'ios') {//getOSName()
  core.setStatusBarStyle = function(opt) {
    if (opt.style === undefined) {
      opt.style = 0;
    }
    this._send('setStatusBarStyle', opt);
  }
}
module.exports = core;
}, {
    asyncDeps:asyncDeps,
    map:mix({"../util":_2},globalMap)
});

define(_20, [_2], function(require, exports, module, __filename, __dirname) {
'use strict';
var util = require('../util');

module.exports = {
  appVersion: '8.0.6',

  share: function(opts) {
    //直接分享渠道计数从1开始
    if (opts.shareType !== undefined) {
      if (util.osName === 'android') {
        //Android下兼容shareType从1开始计数
        opts.shareType += 1;
      }
    }
    opts.feed = this._parseFeed(opts.feed);
    opts.url = this._tidyUrlParams(opts.url);
    
    this._send('share', opts);
  }

};
}, {
    asyncDeps:asyncDeps,
    map:mix({"../util":_2},globalMap)
});

define(_21, [_2], function(require, exports, module, __filename, __dirname) {
'use strict';
var util = require('../util');

var core = {
    appVersion: '8.1.0'
};

if (util.osName === 'ios') {
    core.getHealthData = function(opts) {
        if (!opts) return;
        // 目前支持的类型
        var typeList = [1];
        var type = opts.quantityType;
        var fail = opts.fail;
        // valid
        if (~typeList.indexOf(type)) {
            _handleDate(opts) && this._send('getHealthData', opts);
        } else {
            typeof fail == 'function' && fail('type error');
        }

        function _handleDate(opts) {
            var start = opts.startDate;
            var end = opts.endDate || new Date();
            var fail = opts.fail;

            start = +new Date(start);
            end = +new Date(end);
            if (start < end) {
                // 单位：秒
                opts.startDate = Math.round(start / 1000);
                opts.endDate = Math.round(end / 1000);
                return true;
            } else {
                typeof fail == 'function' && fail('date error');
            }
        }
    };
    core.prompt = function(opt) {
        if (!opt.placeholder) {
            opt.placeholder = '';
        }
        this._send('prompt', opt);
    };
}

module.exports = core;

}, {
    asyncDeps:asyncDeps,
    map:mix({"../util":_2},globalMap)
});

define(_22, [_2], function(require, exports, module, __filename, __dirname) {
'use strict';
var util = require('../util');

module.exports = {
  appVersion: '8.1.2',

  share: function(opts) {
    
    opts.feed = this._parseFeed(opts.feed);
    opts.url = this._tidyUrlParams(opts.url);
    
    this._send('share', opts);
  },
  setBarrageEnabled: function(opts) {
    this._send('setBarrageEnabled',opts);
  }

};
}, {
    asyncDeps:asyncDeps,
    map:mix({"../util":_2},globalMap)
});

define(_23, [_2], function(require, exports, module, __filename, __dirname) {
'use strict';
var util = require('../util');
var batchAPI = [
    'setLLButton',
    'setLRButton',
    'setRLButton',
    'setRRButton'
];

var Core = module.exports = {
    appVersion: '8.1.4',
    publish: function(opt) {
        var bizname = this._getBizName(opt);
        var CONSTS = ['phoneChanged', 'AccountBindChange'];
        if (/2Native/i.test(opt.type) || ~CONSTS.indexOf(opt.action)) {
            delete opt.type;
            this._send('publish', opt);
        } else if (bizname) {
            opt.action = bizname + ':' + opt.action;
            delete opt.type;
            this._send('publish', opt);
        }
    }
};

batchAPI.forEach(function (api) {
  Core[api] = _actionMapping(api);
});

function _actionMapping(method) {
    return function (opt) {
        if (opt && opt.icon) {
            opt.icon = _convertIcon(opt.icon);
        }
        this._send(method, opt);
    };
}

function _convertIcon(icon) {
    var mapList = {
        'H5_Favorite_On': 'ic_action_favorite_on_normal',
        'H5_Favorite_Off': 'ic_action_favorite_off_normal'
    };
    if (/android/i.test(util.osName)) {
        return mapList[icon] || icon;
    }
    return icon;
}
}, {
    asyncDeps:asyncDeps,
    map:mix({"../util":_2},globalMap)
});

define(_24, [_2], function(require, exports, module, __filename, __dirname) {
var util = require('../util');

var Patch = {
	appVersion: '8.1.6',
	pickCity: function(opts) {
		var type = opts && opts.type;
		if (type === undefined || type == 0 || type == 1) {
			this._send('pickCity', opts);
		} else {
			console.log('param error');
			typeof opts.fail == 'function' && opts.fail();
		}
	},
	analyticsTag: function(opts) {
		if (opts && opts.channel && opts.key && opts.value) {
			typeof opts.value == 'string' || (opts.value = JSON.stringify(opts.value));
			this._send('analyticsTag', opts);
		} else {
			console.log('param error');
			typeof opts.fail == 'function' && opts.fail();
		}
	}
};

if (util.osName === 'ios') {
	Patch.setPullDown = function(opts) {
		var callCount = 0;
		var success = opts.success;
		opts.success = function(res) {
			//解决8.1.6 ios下无法区分success和handle事件的BUG
			callCount++;
			if (callCount > 1) {
				opts.handle(res);
			}else{
				success(res);
			}
		}
		this._send('setPullDown',opts);
		
	}
}

module.exports = Patch;
}, {
    asyncDeps:asyncDeps,
    map:mix({"../util":_2},globalMap)
});

define(_27, [], function(require, exports, module, __filename, __dirname) {
'use strict';

exports.mapSeries = function(items, process, callback) {
    var count = items.length;
    var current = 0;
    var results = [];

    function done(err, result) {
        if (err) {
            return callback(err);
        }

        current++;
        results.push(result);
        if(current !== count){
            process(items[current], done);
        }else{
            callback(null, results);
        }
    }

    process(items[current], done);
};
}, {
    asyncDeps:asyncDeps,
    map:globalMap
});
})();_use("dpapp@1.4.12",function(){});