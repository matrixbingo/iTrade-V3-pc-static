/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	(function (Host) {
	  var core = __webpack_require__(1);
	  var util = __webpack_require__(20);
	  var apis = __webpack_require__(21);

	  __webpack_require__(22);
	  
	  var patchVersion = function(version, patch) {
	    if (core.Semver.gte(util.appVersion, version)) {
	        core.patchForType(util.appVersion, patch);
	    }
	  };

	  patchVersion('7.0.0', __webpack_require__(23));
	  patchVersion('7.1.0', __webpack_require__(24));
	  patchVersion('7.2.0', __webpack_require__(25));
	  patchVersion('7.5.0', __webpack_require__(26));
	  patchVersion('7.6.0', __webpack_require__(27));
	  patchVersion('7.8.0', __webpack_require__(28));
	  patchVersion('7.9.1', __webpack_require__(29));
	  patchVersion('7.9.2', __webpack_require__(31));
	  patchVersion('7.9.4', __webpack_require__(32));
	  patchVersion('7.9.6', __webpack_require__(33));
	  patchVersion('8.0.0', __webpack_require__(34));
	  patchVersion('8.0.4', __webpack_require__(35));
	  patchVersion('8.0.6', __webpack_require__(36));
	  patchVersion('8.1.0', __webpack_require__(37));

	  core.apis = apis;
	  core.decorate();

	  apis.forEach(function (api) {
	    if (!core[api]) {
	      core[api] = core._notImplemented;
	    }
	  });
	  // Export DPApp object, if support AMD, CMD, CommonJS.
	  if (true) {
	    module.exports = core;
	  }
	  // Export DPApp object to Host
	  if (typeof Host !== 'undefined') {
	    if(Host.DPApp){
	      core._mixin(Host.DPApp, core);
	    }else{
	      Host.DPApp = core;
	    }
	  }

	}(window));

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var Core = __webpack_require__(2);
	var mixin = __webpack_require__(19);
	var util = __webpack_require__(20);

	var NOOP = function(){};

	var core = module.exports = new Core({
	  hippoPrefix:'dpapp',
	  getTypeFromUA: util.getWebviewVersion,
	  apis: [],
	  allowBeforeReady: ['getRequestId'],
	  isOldVersion: function(){
	    return this.uaType() == '6.9.x';
	  },
	  cache: {},
	  Share: {
	    WECHAT_FRIENDS: 0,
	    WECHAT_TIMELINE: 1,
	    QQ: 2,
	    SMS: 3,
	    WEIBO: 4,
	    QZONE: 5,
	    EMAIL: 6,
	    COPY: 7
	  },
	  _tidyUrlParams: function(url){
	    var splited = url.split('?');
	    var qs = splited[1];
	    var reserved = [];
	    if(!qs){
	      return splited[0];
	    }else{
	      qs.split('&').forEach(function(q){
	        var k = q.split('=')[0];
	        if(!/^(newtoken|token)$/.test(k)){
	          reserved.push(q);
	        }
	      });
	      return [splited[0], reserved.join('&')].join('?');
	    }
	  },
	  _getEnv : function(callback) {
	    var self = this;
	    this._doSendMessage('getEnv', {}, function(env){
	      self.cache['env'] = env;
	      callback.call(this, env);
	    });
	  },
	  _captal: function(str) {
	    return str.slice(0, 1).toUpperCase() + str.slice(1);
	  },
	  _getBizName: function(opt) {
	    var fail = opt.fail;
	    var bizname = this._cfg.bizname;
	    if (!bizname) {
	      fail && fail('use `DPApp.config({bizname:"<your-bizname>"})` first');
	      return false;
	    } else {
	      return bizname;
	    }
	  },
	  isStatusOK : NOOP,
	  did_handle_callback : NOOP, 
	  _doSendMessage: function (method, args, callback) {
	    var self = this;
	    var hasCallback = callback && typeof callback == 'function';
	    this.log('调用方法', method, args);

	    /**
	     * pass 0 as callbackId
	     * thus _callbacks[callbackId] is undefined
	     * nothing will happen
	     * @type {Number}
	     */
	    var callbackId = hasCallback ? this._generateCallbackId() : 0;
	    var callbackName = this._generateCallbackName(callbackId);
	    
	    if (hasCallback){
	      window[callbackName] = callback;
	    }

	    /**
	     * check type for args
	     */
	    if(!args || typeof args !== 'object'){
	      args = {};
	    }

	    // 某些版本app很任性的把callbackId参数放到args里了
	    args.callbackId = callbackId;
	    args = JSON.stringify(args);

	    var _DPApp = window._DPApp;

	    var bridgeUrl = 'js://_?method=' + method + '&args=' + encodeURIComponent(args) + '&callbackId=' + callbackId;
	    this.log('创建iframe ' + method, "callbackId:" + callbackId);

	    this._createIframe(bridgeUrl); 
	    
	  },
	  _send: function(method, args){
	    args = args || {};
	    var self = this;
	    var _success = args.success;
	    var _fail = args.fail;
	    var _handle = args.handle;

	    var fail = function(result){
	      self.log('调用失败 ' + method, result);
	      _fail && _fail.call(self, result);
	    }

	    var success = function(result){
	      self.log('调用成功 ' + method, result);
	      _success && _success.call(self, result);
	    }

	    var handle = function(result){
	      self.log('回调 ' + method, result);
	      _handle && _handle.call(self, result);
	    }

	    var callback = (_success || _fail || _handle) ? function(result){
	      var status = result.status;

	      if(result.result != "next"){
	        delete result.result;
	      }
	      if(status == "success"){
	        success && success(result);
	      }else if(status == "action"){
	        handle && handle(result);
	      }else{
	        fail && fail(result);
	      }
	    } : null;
	    this._sendMessage(method, args, callback);
	  },
	});

	if(window.DPApp){
	  core = mixin(window.DPApp, core);
	}

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var Core = __webpack_require__(3);
	var NativeCore = __webpack_require__(16);
	var Network = __webpack_require__(18);
	var Promise = __webpack_require__(6);

	Core.prototype._mixin(Core.prototype, NativeCore);
	Core.prototype._mixin(Core.prototype, Network);
	Core.prototype.all = function(list){
		return Promise.all(list);
	};
	module.exports = Core;

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	function mixin(to, from) {
	  for (var key in from) {
	    to[key] = from[key];
	  }
	  return to;
	}

	var Core = module.exports = function(options){
	  options = options || {};
	  var self = this;
	  for(var key in options){
	    this[key] = options[key];
	  }


	  var apis = options.apis || __webpack_require__(4);
	  (options.extraApis || []).forEach(function(name){
	    if(apis.indexOf(name) === -1){
	      apis.push(name);
	    }
	  });

	  this.apis = apis;
	  this.allowBeforeReady = this.allowBeforeReady || ["getRequestId"];


	  apis.forEach(function(name) {
	    if(!self[name]){
	      self[name] = function(options) {
	        self._send(name, options);
	      }
	    }
	  });

	  this.decorate();
	};

	Core.prototype = {
	  _cfg: {
	    debug: false
	  },
	  _isProduct: !!location.href.match(".dianping.com"),
	  _isReady: false,
	  config: function(config) {
	    for(var key in config){
	      this._cfg[key] = config[key];
	    }
	  },
	  /**
	   * 是否为古早版本
	   */
	  isOldVersion: function(){
	    return false;
	  },
	  getQuery: function (){
	    var query = location.search.slice(1);
	    var ret = {};
	    query.split("&").forEach(function(pair){
	      var splited = pair.split("=");
	      ret[splited[0]] = splited[1];
	    });
	    return ret;
	  },
	  patchForType: function(version, patch){
	    if(this.uaType() == version){
	      this.extend(patch);
	      this.decorate();
	    }
	  },
	  decorate: __webpack_require__(5),
	  Semver: {
	    eq: function(a, b) {
	      return a === b;
	    },
	    gt: function(a, b) {
	      var splitedA = a ? a.split(".") : [];
	      var splitedB = b ? b.split(".") : [];
	      [0,1,2].forEach(function(i){
	        splitedA[i] = splitedA[i] || 0;
	        splitedB[i] = splitedB[i] || 0;
	      });
	      if (+splitedA[0] !== +splitedB[0]) {
	        return +splitedA[0] > +splitedB[0];
	      } else {
	        if (+splitedA[1] !== +splitedB[1]) {
	          return +splitedA[1] > +splitedB[1];
	        } else {
	          return +splitedA[2] > +(splitedB[2] || 0);
	        }
	      }
	    },
	    lt: function(a, b) {
	      return !this.gte(a, b);
	    },
	    gte: function(a, b) {
	      return this.eq(a, b) || this.gt(a, b);
	    },
	    lte: function(a, b) {
	      return this.eq(a, b) || this.lt(a, b);
	    }
	  },
	  _parseUA: function(ua){
	    var osName, osVersion, versionMatch;
	    if (ua.match(/iPhone/)) {
	      osName = "iphone";
	      osVersion = ua.match(/iPhone\sOS\s([\d_]+)/i)[1].replace(/_/g, ".");
	    } else if (ua.match(/Android/)) {
	      osName = "android";
	      versionMatch = ua.match(/Android[\s|\/]([\w\.]+)/);
	      osVersion = versionMatch && versionMatch[1];
	    } else {
	      osName = null;
	      osVersion = null;
	    }
	    return {
	      name: osName,
	      version: osVersion
	    }
	  },
	  getTypeFromUA: function(userAgent){
	    return /dp\/com\.dianping\.(\w+)\//.test(userAgent)
	      ? userAgent.match(/dp\/com\.dianping\.(\w+)\//)[1]
	      : "web"
	  },
	  uaType: function(){
	    return this.getTypeFromUA(navigator.userAgent);
	  },
	  _trace: function(name, params){
	    if(!this.hippoPrefix){return;}
	    var logFact = (this._cfg && this._cfg.logFact) || 0.05;
	    params = params || {};
	    params = this._mixin(params, {
	      module: this.hippoPrefix + "_" + name
	    });
	    if(Math.random() < logFact){
	      console.log("_trace", name)
	      window._hip && _hip.push(['mv', params]);
	    }
	  },
	  log: function() {

	    var message = [];
	    for(var i=0; i < arguments.length; i++){
	      if(typeof arguments[i] == "string"){
	        message.push(arguments[i]);
	      }else if(arguments[i] != undefined){
	        message.push(JSON.stringify(arguments[i]));
	      }
	    }

	    message = message.join(" ");
	    if (this._cfg && this._cfg.debug) {
	      setTimeout(function(){
	        alert(message);
	      });
	    }else{
	      console.log(message);
	    }
	  },
	  _mixin: mixin,
	  extend: function(args) {
	    return this._mixin(this, args);
	  },
	  _notImplemented: function notImplemented(opt) {
	    opt && opt.fail && opt.fail({
	      errMsg:"ERR_NOT_IMPLEMENTED"
	    });
	  },
	  isSupport: function(funcName) {
	    var api = this[funcName];
	    return !!(api
	      && typeof api == "function"
	      && api != this._notImplemented
	      && api._notReady != true)
	  }
	};

	Core.prototype._osUA = Core.prototype._parseUA(navigator.userAgent);

/***/ },
/* 4 */
/***/ function(module, exports) {

	module.exports = [
	  "getVersion", "getNetworkType", "getContactList", "pickContact",
	  "getRequestId", "getDeviceInfo", "clearStorage", "store", "retrieve", "publish", "subscribe", "unsubscribe", "openScheme", "jumpToScheme", "closeWindow", "sendSMS",
	  "downloadImage", "setBackgroundColor", "setTitle", "setLLButton", "setLRButton", "setRLButton", "setRRButton", "isInstalledApp",
	  "alert", "prompt", "confirm", "actionSheet"
	];

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	var Promise = __webpack_require__(6);

	module.exports = function (allowBeforeReady){
	  var target = this;
	  var apis = this.apis;
	  var allowBeforeReady = this.allowBeforeReady;

	  apis.forEach(function(name){
	    if(!target[name]){
	      target[name] = target._notImplemented;
	    }
	  });

	  apis.forEach(function(api){
	    var _origin = target[api];
	    if(target[api] && target[api]._decorated){
	      return;
	    }
	    target[api] = function(args){
	      var _args = target._mixin({}, args);
	      target._trace(api + "_call");
	      var _success = _args.success;
	      var _fail = _args.fail;
	      var _wrapped_fail = function(result){
	        if(!_fail){
	          if(target.onerror){
	            target.onerror({
	              api: api,
	              err: result
	            });
	          }else{
	            var errorMessage = result.errMsg ? result.errMsg : JSON.stringify(result);
	            var err = new Error(errorMessage);
	            err.name = "DPAppError";
	            console.warn("`DPApp." + api + "` call faild");
	            target._trace('throw');
	            console.warn(new Error(err));
	          }
	        }else{
	          _fail(result);
	        }
	      }
	      var zero = +new Date;
	      _args.success = function(result){
	        target._trace(api + "_success", {
	          time: +new Date - zero,
	        });
	        _success && _success(result);
	      };
	      _args.fail = function(result){
	        var note = {};
	        note.args = args;
	        note.result = result;
	        target._trace(api + "_fail", {
	          time: +new Date - zero,
	          note: JSON.stringify(note)
	        });
	        _wrapped_fail(result);
	      }

	      if(!this._isReady
	        && allowBeforeReady.indexOf(api) === -1
	        && !target._isProduct // 非正式环境
	        && target.isOldVersion() // 且非新版本，为了判断环境，必须wrap在DPApp.ready中
	      ){
	        _wrapped_fail("use `DPApp.ready(fn)` to wrap api calls");
	        return;
	      }

	      return new Promise(function(resolve, reject){
	        var origin_success = _args.success;
	        var origin_fail = _args.fail;
	        var success = function(result){
	          origin_success(result);
	          resolve(result);
	        }
	        var fail = function(result){
	          origin_fail(result);
	          if(!_fail){
	            reject(result);
	          }
	        }
	        _args.success = success;
	        _args.fail = fail;
	        _origin.call(target, _args);
	      });
	    }
	    target[api]._decorated = true;
	    target[api]._notReady = _origin == target._notImplemented;

	  });
	}

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(7)


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(8);
	__webpack_require__(10);
	__webpack_require__(11);
	__webpack_require__(12);
	__webpack_require__(13);
	__webpack_require__(15);


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var asap = __webpack_require__(9);

	function noop() {}

	// States:
	//
	// 0 - pending
	// 1 - fulfilled with _value
	// 2 - rejected with _value
	// 3 - adopted the state of another promise, _value
	//
	// once the state is no longer pending (0) it is immutable

	// All `_` prefixed properties will be reduced to `_{random number}`
	// at build time to obfuscate them and discourage their use.
	// We don't use symbols or Object.defineProperty to fully hide them
	// because the performance isn't good enough.


	// to avoid using try/catch inside critical functions, we
	// extract them to here.
	var LAST_ERROR = null;
	var IS_ERROR = {};
	function getThen(obj) {
	  try {
	    return obj.then;
	  } catch (ex) {
	    LAST_ERROR = ex;
	    return IS_ERROR;
	  }
	}

	function tryCallOne(fn, a) {
	  try {
	    return fn(a);
	  } catch (ex) {
	    LAST_ERROR = ex;
	    return IS_ERROR;
	  }
	}
	function tryCallTwo(fn, a, b) {
	  try {
	    fn(a, b);
	  } catch (ex) {
	    LAST_ERROR = ex;
	    return IS_ERROR;
	  }
	}

	module.exports = Promise;

	function Promise(fn) {
	  if (typeof this !== 'object') {
	    throw new TypeError('Promises must be constructed via new');
	  }
	  if (typeof fn !== 'function') {
	    throw new TypeError('not a function');
	  }
	  this._45 = 0;
	  this._81 = 0;
	  this._65 = null;
	  this._54 = null;
	  if (fn === noop) return;
	  doResolve(fn, this);
	}
	Promise._10 = null;
	Promise._97 = null;
	Promise._61 = noop;

	Promise.prototype.then = function(onFulfilled, onRejected) {
	  if (this.constructor !== Promise) {
	    return safeThen(this, onFulfilled, onRejected);
	  }
	  var res = new Promise(noop);
	  handle(this, new Handler(onFulfilled, onRejected, res));
	  return res;
	};

	function safeThen(self, onFulfilled, onRejected) {
	  return new self.constructor(function (resolve, reject) {
	    var res = new Promise(noop);
	    res.then(resolve, reject);
	    handle(self, new Handler(onFulfilled, onRejected, res));
	  });
	};
	function handle(self, deferred) {
	  while (self._81 === 3) {
	    self = self._65;
	  }
	  if (Promise._10) {
	    Promise._10(self);
	  }
	  if (self._81 === 0) {
	    if (self._45 === 0) {
	      self._45 = 1;
	      self._54 = deferred;
	      return;
	    }
	    if (self._45 === 1) {
	      self._45 = 2;
	      self._54 = [self._54, deferred];
	      return;
	    }
	    self._54.push(deferred);
	    return;
	  }
	  handleResolved(self, deferred);
	}

	function handleResolved(self, deferred) {
	  asap(function() {
	    var cb = self._81 === 1 ? deferred.onFulfilled : deferred.onRejected;
	    if (cb === null) {
	      if (self._81 === 1) {
	        resolve(deferred.promise, self._65);
	      } else {
	        reject(deferred.promise, self._65);
	      }
	      return;
	    }
	    var ret = tryCallOne(cb, self._65);
	    if (ret === IS_ERROR) {
	      reject(deferred.promise, LAST_ERROR);
	    } else {
	      resolve(deferred.promise, ret);
	    }
	  });
	}
	function resolve(self, newValue) {
	  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
	  if (newValue === self) {
	    return reject(
	      self,
	      new TypeError('A promise cannot be resolved with itself.')
	    );
	  }
	  if (
	    newValue &&
	    (typeof newValue === 'object' || typeof newValue === 'function')
	  ) {
	    var then = getThen(newValue);
	    if (then === IS_ERROR) {
	      return reject(self, LAST_ERROR);
	    }
	    if (
	      then === self.then &&
	      newValue instanceof Promise
	    ) {
	      self._81 = 3;
	      self._65 = newValue;
	      finale(self);
	      return;
	    } else if (typeof then === 'function') {
	      doResolve(then.bind(newValue), self);
	      return;
	    }
	  }
	  self._81 = 1;
	  self._65 = newValue;
	  finale(self);
	}

	function reject(self, newValue) {
	  self._81 = 2;
	  self._65 = newValue;
	  if (Promise._97) {
	    Promise._97(self, newValue);
	  }
	  finale(self);
	}
	function finale(self) {
	  if (self._45 === 1) {
	    handle(self, self._54);
	    self._54 = null;
	  }
	  if (self._45 === 2) {
	    for (var i = 0; i < self._54.length; i++) {
	      handle(self, self._54[i]);
	    }
	    self._54 = null;
	  }
	}

	function Handler(onFulfilled, onRejected, promise){
	  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
	  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
	  this.promise = promise;
	}

	/**
	 * Take a potentially misbehaving resolver function and make sure
	 * onFulfilled and onRejected are only called once.
	 *
	 * Makes no guarantees about asynchrony.
	 */
	function doResolve(fn, promise) {
	  var done = false;
	  var res = tryCallTwo(fn, function (value) {
	    if (done) return;
	    done = true;
	    resolve(promise, value);
	  }, function (reason) {
	    if (done) return;
	    done = true;
	    reject(promise, reason);
	  })
	  if (!done && res === IS_ERROR) {
	    done = true;
	    reject(promise, LAST_ERROR);
	  }
	}


/***/ },
/* 9 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";

	// Use the fastest means possible to execute a task in its own turn, with
	// priority over other events including IO, animation, reflow, and redraw
	// events in browsers.
	//
	// An exception thrown by a task will permanently interrupt the processing of
	// subsequent tasks. The higher level `asap` function ensures that if an
	// exception is thrown by a task, that the task queue will continue flushing as
	// soon as possible, but if you use `rawAsap` directly, you are responsible to
	// either ensure that no exceptions are thrown from your task, or to manually
	// call `rawAsap.requestFlush` if an exception is thrown.
	module.exports = rawAsap;
	function rawAsap(task) {
	    if (!queue.length) {
	        requestFlush();
	        flushing = true;
	    }
	    // Equivalent to push, but avoids a function call.
	    queue[queue.length] = task;
	}

	var queue = [];
	// Once a flush has been requested, no further calls to `requestFlush` are
	// necessary until the next `flush` completes.
	var flushing = false;
	// `requestFlush` is an implementation-specific method that attempts to kick
	// off a `flush` event as quickly as possible. `flush` will attempt to exhaust
	// the event queue before yielding to the browser's own event loop.
	var requestFlush;
	// The position of the next task to execute in the task queue. This is
	// preserved between calls to `flush` so that it can be resumed if
	// a task throws an exception.
	var index = 0;
	// If a task schedules additional tasks recursively, the task queue can grow
	// unbounded. To prevent memory exhaustion, the task queue will periodically
	// truncate already-completed tasks.
	var capacity = 1024;

	// The flush function processes all tasks that have been scheduled with
	// `rawAsap` unless and until one of those tasks throws an exception.
	// If a task throws an exception, `flush` ensures that its state will remain
	// consistent and will resume where it left off when called again.
	// However, `flush` does not make any arrangements to be called again if an
	// exception is thrown.
	function flush() {
	    while (index < queue.length) {
	        var currentIndex = index;
	        // Advance the index before calling the task. This ensures that we will
	        // begin flushing on the next task the task throws an error.
	        index = index + 1;
	        queue[currentIndex].call();
	        // Prevent leaking memory for long chains of recursive calls to `asap`.
	        // If we call `asap` within tasks scheduled by `asap`, the queue will
	        // grow, but to avoid an O(n) walk for every task we execute, we don't
	        // shift tasks off the queue after they have been executed.
	        // Instead, we periodically shift 1024 tasks off the queue.
	        if (index > capacity) {
	            // Manually shift all values starting at the index back to the
	            // beginning of the queue.
	            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
	                queue[scan] = queue[scan + index];
	            }
	            queue.length -= index;
	            index = 0;
	        }
	    }
	    queue.length = 0;
	    index = 0;
	    flushing = false;
	}

	// `requestFlush` is implemented using a strategy based on data collected from
	// every available SauceLabs Selenium web driver worker at time of writing.
	// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593

	// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that
	// have WebKitMutationObserver but not un-prefixed MutationObserver.
	// Must use `global` instead of `window` to work in both frames and web
	// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.
	var BrowserMutationObserver = global.MutationObserver || global.WebKitMutationObserver;

	// MutationObservers are desirable because they have high priority and work
	// reliably everywhere they are implemented.
	// They are implemented in all modern browsers.
	//
	// - Android 4-4.3
	// - Chrome 26-34
	// - Firefox 14-29
	// - Internet Explorer 11
	// - iPad Safari 6-7.1
	// - iPhone Safari 7-7.1
	// - Safari 6-7
	if (typeof BrowserMutationObserver === "function") {
	    requestFlush = makeRequestCallFromMutationObserver(flush);

	// MessageChannels are desirable because they give direct access to the HTML
	// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera
	// 11-12, and in web workers in many engines.
	// Although message channels yield to any queued rendering and IO tasks, they
	// would be better than imposing the 4ms delay of timers.
	// However, they do not work reliably in Internet Explorer or Safari.

	// Internet Explorer 10 is the only browser that has setImmediate but does
	// not have MutationObservers.
	// Although setImmediate yields to the browser's renderer, it would be
	// preferrable to falling back to setTimeout since it does not have
	// the minimum 4ms penalty.
	// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and
	// Desktop to a lesser extent) that renders both setImmediate and
	// MessageChannel useless for the purposes of ASAP.
	// https://github.com/kriskowal/q/issues/396

	// Timers are implemented universally.
	// We fall back to timers in workers in most engines, and in foreground
	// contexts in the following browsers.
	// However, note that even this simple case requires nuances to operate in a
	// broad spectrum of browsers.
	//
	// - Firefox 3-13
	// - Internet Explorer 6-9
	// - iPad Safari 4.3
	// - Lynx 2.8.7
	} else {
	    requestFlush = makeRequestCallFromTimer(flush);
	}

	// `requestFlush` requests that the high priority event queue be flushed as
	// soon as possible.
	// This is useful to prevent an error thrown in a task from stalling the event
	// queue if the exception handled by Node.js’s
	// `process.on("uncaughtException")` or by a domain.
	rawAsap.requestFlush = requestFlush;

	// To request a high priority event, we induce a mutation observer by toggling
	// the text of a text node between "1" and "-1".
	function makeRequestCallFromMutationObserver(callback) {
	    var toggle = 1;
	    var observer = new BrowserMutationObserver(callback);
	    var node = document.createTextNode("");
	    observer.observe(node, {characterData: true});
	    return function requestCall() {
	        toggle = -toggle;
	        node.data = toggle;
	    };
	}

	// The message channel technique was discovered by Malte Ubl and was the
	// original foundation for this library.
	// http://www.nonblocking.io/2011/06/windownexttick.html

	// Safari 6.0.5 (at least) intermittently fails to create message ports on a
	// page's first load. Thankfully, this version of Safari supports
	// MutationObservers, so we don't need to fall back in that case.

	// function makeRequestCallFromMessageChannel(callback) {
	//     var channel = new MessageChannel();
	//     channel.port1.onmessage = callback;
	//     return function requestCall() {
	//         channel.port2.postMessage(0);
	//     };
	// }

	// For reasons explained above, we are also unable to use `setImmediate`
	// under any circumstances.
	// Even if we were, there is another bug in Internet Explorer 10.
	// It is not sufficient to assign `setImmediate` to `requestFlush` because
	// `setImmediate` must be called *by name* and therefore must be wrapped in a
	// closure.
	// Never forget.

	// function makeRequestCallFromSetImmediate(callback) {
	//     return function requestCall() {
	//         setImmediate(callback);
	//     };
	// }

	// Safari 6.0 has a problem where timers will get lost while the user is
	// scrolling. This problem does not impact ASAP because Safari 6.0 supports
	// mutation observers, so that implementation is used instead.
	// However, if we ever elect to use timers in Safari, the prevalent work-around
	// is to add a scroll event listener that calls for a flush.

	// `setTimeout` does not call the passed callback if the delay is less than
	// approximately 7 in web workers in Firefox 8 through 18, and sometimes not
	// even then.

	function makeRequestCallFromTimer(callback) {
	    return function requestCall() {
	        // We dispatch a timeout with a specified delay of 0 for engines that
	        // can reliably accommodate that request. This will usually be snapped
	        // to a 4 milisecond delay, but once we're flushing, there's no delay
	        // between events.
	        var timeoutHandle = setTimeout(handleTimer, 0);
	        // However, since this timer gets frequently dropped in Firefox
	        // workers, we enlist an interval handle that will try to fire
	        // an event 20 times per second until it succeeds.
	        var intervalHandle = setInterval(handleTimer, 50);

	        function handleTimer() {
	            // Whichever timer succeeds will cancel both timers and
	            // execute the callback.
	            clearTimeout(timeoutHandle);
	            clearInterval(intervalHandle);
	            callback();
	        }
	    };
	}

	// This is for `asap.js` only.
	// Its name will be periodically randomized to break any code that depends on
	// its existence.
	rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;

	// ASAP was originally a nextTick shim included in Q. This was factored out
	// into this ASAP package. It was later adapted to RSVP which made further
	// amendments. These decisions, particularly to marginalize MessageChannel and
	// to capture the MutationObserver implementation in a closure, were integrated
	// back into ASAP proper.
	// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Promise = __webpack_require__(8);

	module.exports = Promise;
	Promise.prototype.done = function (onFulfilled, onRejected) {
	  var self = arguments.length ? this.then.apply(this, arguments) : this;
	  self.then(null, function (err) {
	    setTimeout(function () {
	      throw err;
	    }, 0);
	  });
	};


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Promise = __webpack_require__(8);

	module.exports = Promise;
	Promise.prototype['finally'] = function (f) {
	  return this.then(function (value) {
	    return Promise.resolve(f()).then(function () {
	      return value;
	    });
	  }, function (err) {
	    return Promise.resolve(f()).then(function () {
	      throw err;
	    });
	  });
	};


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	//This file contains the ES6 extensions to the core Promises/A+ API

	var Promise = __webpack_require__(8);

	module.exports = Promise;

	/* Static Functions */

	var TRUE = valuePromise(true);
	var FALSE = valuePromise(false);
	var NULL = valuePromise(null);
	var UNDEFINED = valuePromise(undefined);
	var ZERO = valuePromise(0);
	var EMPTYSTRING = valuePromise('');

	function valuePromise(value) {
	  var p = new Promise(Promise._61);
	  p._81 = 1;
	  p._65 = value;
	  return p;
	}
	Promise.resolve = function (value) {
	  if (value instanceof Promise) return value;

	  if (value === null) return NULL;
	  if (value === undefined) return UNDEFINED;
	  if (value === true) return TRUE;
	  if (value === false) return FALSE;
	  if (value === 0) return ZERO;
	  if (value === '') return EMPTYSTRING;

	  if (typeof value === 'object' || typeof value === 'function') {
	    try {
	      var then = value.then;
	      if (typeof then === 'function') {
	        return new Promise(then.bind(value));
	      }
	    } catch (ex) {
	      return new Promise(function (resolve, reject) {
	        reject(ex);
	      });
	    }
	  }
	  return valuePromise(value);
	};

	Promise.all = function (arr) {
	  var args = Array.prototype.slice.call(arr);

	  return new Promise(function (resolve, reject) {
	    if (args.length === 0) return resolve([]);
	    var remaining = args.length;
	    function res(i, val) {
	      if (val && (typeof val === 'object' || typeof val === 'function')) {
	        if (val instanceof Promise && val.then === Promise.prototype.then) {
	          while (val._81 === 3) {
	            val = val._65;
	          }
	          if (val._81 === 1) return res(i, val._65);
	          if (val._81 === 2) reject(val._65);
	          val.then(function (val) {
	            res(i, val);
	          }, reject);
	          return;
	        } else {
	          var then = val.then;
	          if (typeof then === 'function') {
	            var p = new Promise(then.bind(val));
	            p.then(function (val) {
	              res(i, val);
	            }, reject);
	            return;
	          }
	        }
	      }
	      args[i] = val;
	      if (--remaining === 0) {
	        resolve(args);
	      }
	    }
	    for (var i = 0; i < args.length; i++) {
	      res(i, args[i]);
	    }
	  });
	};

	Promise.reject = function (value) {
	  return new Promise(function (resolve, reject) {
	    reject(value);
	  });
	};

	Promise.race = function (values) {
	  return new Promise(function (resolve, reject) {
	    values.forEach(function(value){
	      Promise.resolve(value).then(resolve, reject);
	    });
	  });
	};

	/* Prototype Methods */

	Promise.prototype['catch'] = function (onRejected) {
	  return this.then(null, onRejected);
	};


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	// This file contains then/promise specific extensions that are only useful
	// for node.js interop

	var Promise = __webpack_require__(8);
	var asap = __webpack_require__(14);

	module.exports = Promise;

	/* Static Functions */

	Promise.denodeify = function (fn, argumentCount) {
	  if (
	    typeof argumentCount === 'number' && argumentCount !== Infinity
	  ) {
	    return denodeifyWithCount(fn, argumentCount);
	  } else {
	    return denodeifyWithoutCount(fn);
	  }
	}

	var callbackFn = (
	  'function (err, res) {' +
	  'if (err) { rj(err); } else { rs(res); }' +
	  '}'
	);
	function denodeifyWithCount(fn, argumentCount) {
	  var args = [];
	  for (var i = 0; i < argumentCount; i++) {
	    args.push('a' + i);
	  }
	  var body = [
	    'return function (' + args.join(',') + ') {',
	    'var self = this;',
	    'return new Promise(function (rs, rj) {',
	    'var res = fn.call(',
	    ['self'].concat(args).concat([callbackFn]).join(','),
	    ');',
	    'if (res &&',
	    '(typeof res === "object" || typeof res === "function") &&',
	    'typeof res.then === "function"',
	    ') {rs(res);}',
	    '});',
	    '};'
	  ].join('');
	  return Function(['Promise', 'fn'], body)(Promise, fn);
	}
	function denodeifyWithoutCount(fn) {
	  var fnLength = Math.max(fn.length - 1, 3);
	  var args = [];
	  for (var i = 0; i < fnLength; i++) {
	    args.push('a' + i);
	  }
	  var body = [
	    'return function (' + args.join(',') + ') {',
	    'var self = this;',
	    'var args;',
	    'var argLength = arguments.length;',
	    'if (arguments.length > ' + fnLength + ') {',
	    'args = new Array(arguments.length + 1);',
	    'for (var i = 0; i < arguments.length; i++) {',
	    'args[i] = arguments[i];',
	    '}',
	    '}',
	    'return new Promise(function (rs, rj) {',
	    'var cb = ' + callbackFn + ';',
	    'var res;',
	    'switch (argLength) {',
	    args.concat(['extra']).map(function (_, index) {
	      return (
	        'case ' + (index) + ':' +
	        'res = fn.call(' + ['self'].concat(args.slice(0, index)).concat('cb').join(',') + ');' +
	        'break;'
	      );
	    }).join(''),
	    'default:',
	    'args[argLength] = cb;',
	    'res = fn.apply(self, args);',
	    '}',
	    
	    'if (res &&',
	    '(typeof res === "object" || typeof res === "function") &&',
	    'typeof res.then === "function"',
	    ') {rs(res);}',
	    '});',
	    '};'
	  ].join('');

	  return Function(
	    ['Promise', 'fn'],
	    body
	  )(Promise, fn);
	}

	Promise.nodeify = function (fn) {
	  return function () {
	    var args = Array.prototype.slice.call(arguments);
	    var callback =
	      typeof args[args.length - 1] === 'function' ? args.pop() : null;
	    var ctx = this;
	    try {
	      return fn.apply(this, arguments).nodeify(callback, ctx);
	    } catch (ex) {
	      if (callback === null || typeof callback == 'undefined') {
	        return new Promise(function (resolve, reject) {
	          reject(ex);
	        });
	      } else {
	        asap(function () {
	          callback.call(ctx, ex);
	        })
	      }
	    }
	  }
	}

	Promise.prototype.nodeify = function (callback, ctx) {
	  if (typeof callback != 'function') return this;

	  this.then(function (value) {
	    asap(function () {
	      callback.call(ctx, null, value);
	    });
	  }, function (err) {
	    asap(function () {
	      callback.call(ctx, err);
	    });
	  });
	}


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	// rawAsap provides everything we need except exception management.
	var rawAsap = __webpack_require__(9);
	// RawTasks are recycled to reduce GC churn.
	var freeTasks = [];
	// We queue errors to ensure they are thrown in right order (FIFO).
	// Array-as-queue is good enough here, since we are just dealing with exceptions.
	var pendingErrors = [];
	var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);

	function throwFirstError() {
	    if (pendingErrors.length) {
	        throw pendingErrors.shift();
	    }
	}

	/**
	 * Calls a task as soon as possible after returning, in its own event, with priority
	 * over other events like animation, reflow, and repaint. An error thrown from an
	 * event will not interrupt, nor even substantially slow down the processing of
	 * other events, but will be rather postponed to a lower priority event.
	 * @param {{call}} task A callable object, typically a function that takes no
	 * arguments.
	 */
	module.exports = asap;
	function asap(task) {
	    var rawTask;
	    if (freeTasks.length) {
	        rawTask = freeTasks.pop();
	    } else {
	        rawTask = new RawTask();
	    }
	    rawTask.task = task;
	    rawAsap(rawTask);
	}

	// We wrap tasks with recyclable task objects.  A task object implements
	// `call`, just like a function.
	function RawTask() {
	    this.task = null;
	}

	// The sole purpose of wrapping the task is to catch the exception and recycle
	// the task object after its single use.
	RawTask.prototype.call = function () {
	    try {
	        this.task.call();
	    } catch (error) {
	        if (asap.onerror) {
	            // This hook exists purely for testing purposes.
	            // Its name will be periodically randomized to break any code that
	            // depends on its existence.
	            asap.onerror(error);
	        } else {
	            // In a web browser, exceptions are not fatal. However, to avoid
	            // slowing down the queue of pending tasks, we rethrow the error in a
	            // lower priority turn.
	            pendingErrors.push(error);
	            requestErrorThrow();
	        }
	    } finally {
	        this.task = null;
	        freeTasks[freeTasks.length] = this;
	    }
	};


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Promise = __webpack_require__(8);

	module.exports = Promise;
	Promise.enableSynchronous = function () {
	  Promise.prototype.isPending = function() {
	    return this.getState() == 0;
	  };

	  Promise.prototype.isFulfilled = function() {
	    return this.getState() == 1;
	  };

	  Promise.prototype.isRejected = function() {
	    return this.getState() == 2;
	  };

	  Promise.prototype.getValue = function () {
	    if (this._81 === 3) {
	      return this._65.getValue();
	    }

	    if (!this.isFulfilled()) {
	      throw new Error('Cannot get a value of an unfulfilled promise.');
	    }

	    return this._65;
	  };

	  Promise.prototype.getReason = function () {
	    if (this._81 === 3) {
	      return this._65.getReason();
	    }

	    if (!this.isRejected()) {
	      throw new Error('Cannot get a rejection reason of a non-rejected promise.');
	    }

	    return this._65;
	  };

	  Promise.prototype.getState = function () {
	    if (this._81 === 3) {
	      return this._65.getState();
	    }
	    if (this._81 === -1 || this._81 === -2) {
	      return 0;
	    }

	    return this._81;
	  };
	};

	Promise.disableSynchronous = function() {
	  Promise.prototype.isPending = undefined;
	  Promise.prototype.isFulfilled = undefined;
	  Promise.prototype.isRejected = undefined;
	  Promise.prototype.getValue = undefined;
	  Promise.prototype.getReason = undefined;
	  Promise.prototype.getState = undefined;
	};


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * count from 1
	 * @type {Number}
	 */
	var _events = {};
	/**
	 * mapping for all callbacks
	 * @type {Object}
	 */
	var pageEvents = ["appear", "disappear"];
	var queue = __webpack_require__(17);
	var q = queue(function(data){
	  DPApp._doSendMessage(data.method, data.args, data.callback);
	});

	module.exports = {
		_dequeueTimeout: null,
	  dequeue: function(){
	    var self = this;
	    setTimeout(function(){
	      DPApp && DPApp.log && DPApp.log("Dequeue");
	      clearTimeout(this._dequeueTimeout);
	      self._dequeueTimeout = null;
	      q.dequeue();
	    }, 0);
	  },
	  ready: function(callback){
	    var self = this;
	    this._send("ready", {
	      success: function(){
	        self._isReady = true;
	        callback();
	      }
	    });
	  },
	  openScheme: function(opt){
	    var url = opt.url;
	    var extra = opt.extra;
	    if(extra){
	      url += "?" + this._convertUrlParams(extra);
	      delete opt.extra;
	      opt.url = url;
	    }
	    this._send('openScheme', opt);
	  },
	  _sendMessage: function(method, args, callback){
	    var self = this;
	    q.push({
	      method: method,
	      args: args,
	      callback: callback
	    });
	    this._dequeueTimeout = setTimeout(function(){
	      self.dequeue();
	    },1000);

	  },
	  // _generateCallbackId: function(){
	  //   var rand = Math.floor(Math.random() * 1000);
	  //   var timestamp = +new Date();
	  //   return +(timestamp + "" + rand);
	  // },
	  _generateCallbackId: function () {
	    var rand = Math.floor(Math.random() * 1000);
	    var timestampStr = (+new Date()).toString();
	    //在DPAPP老版本中callbackId为int型，故只选取8位
	    var timestamp = timestampStr.substr(timestampStr.length - 5, 5);
	    return +(timestamp + "" + rand);
	  },
	  _generateCallbackName: function(callbackId){
	    return "DPApp_callback_" + callbackId;
	  },
	  /**
	   * send message to native
	   * @param  {String}   method
	   * @param  {Object}   args
	   * @param  {Function} callback
	   */
	  _doSendMessage: function (method, args, callback) {
	      var hasCallback = callback && typeof callback == 'function';
	      this.log('调用方法', method, args);

	      /**
	       * pass 0 as callbackId
	       * thus _callbacks[callbackId] is undefined
	       * nothing will happen
	       * @type {Number}
	       */
	      var callbackId = hasCallback ? this._generateCallbackId() : 0;
	      
	      if (hasCallback){
	        window[this._generateCallbackName(callbackId)] = callback;
	      }

	      /**
	       * check type for args
	       */
	      if(!args || typeof args !== 'object'){
	        args = {};
	      }

	      // 某些版本app很任性的把callbackId参数放到args里了
	      args.callbackId = callbackId;
	      args = JSON.stringify(args);

	      var bridgeUrl = 'js://_?method=' + method + '&args=' + encodeURIComponent(args) + '&callbackId=' + callbackId;

	      this.log('创建iframe ' + method, "callbackId:" + callbackId);
	      this._createIframe(bridgeUrl);
	  },
	  _createNode: function(src, type){
	    /**
	     * create node
	     * and native will intercept and handle the process
	     */
	    var node = document.createElement(type);
	    node.style.display = 'none';

	    function removeNode(){
	      node.onload = node.onerror = null;
	      node.parentNode && node.parentNode.removeChild(node);
	    }
	    /**
	     * remove node after loaded
	     */
	    node.onload = node.onerror = removeNode;
	    setTimeout(removeNode, 5000);
	    node.src = src;
	    document.body.appendChild(node);
	  },
	  _createIframe: function(src){
	    this._createNode(src, "iframe");
	  },
	  _send: function(method, args){
	    args = args || {};
	    var self = this;
	    var _success = args.success;
	    var _fail = args.fail;
	    var _handle = args.handle;

	    var fail = function(result){
	      self.log('调用失败 ' + method, result);
	      _fail && _fail.call(self, result);
	    }

	    var success = function(result){
	      self.log('调用成功 ' + method, result);
	      _success && _success.call(self, result);
	    }

	    var handle = function(result){
	      self.log('回调 ' + method, result);
	      _handle && _handle.call(self, result);
	    }

	    var callback = (_success || _fail || _handle) ? function(result){
	      var status = result.status;
	      if(result.result != "next"){
	        delete result.result;
	      }
	      if(status == "success"){
	        success && success(result);
	      }else if(status == "action"){
	        handle && handle(result);
	      }else{
	        fail && fail(result);
	      }
	    } : null;

	    //统一封装ready，业务无须关心ready的时机，当发生第一次API调用时先确保ready状态
	    if (this._isReady) {
	      this._sendMessage(method, args, callback);  
	    }else{
	      this.ready(function () {
	        this._sendMessage(method, args, callback);
	      });
	    }
	  },

	  _convertUrlParams: function(params){
	    var result = [];
	    for(var i in params){
	      result.push(i + "=" + encodeURIComponent(params[i]));
	    }
	    return result.join("&");
	  },
	  _sanitizeAjaxOpts: function(args){
	    args.method = args.method || "get";
	    args.data = args.data || "";
	    var url = args.url;
	    var data = args.data;

	    if (args.method == "get") {
	      var params = [];
	      for (var p in data) {
	        if (data.hasOwnProperty(p) && (data[p] || data[p] === 0)) {  // allow `something=0' param
	          params.push(p + '=' + encodeURIComponent(data[p]));
	        }
	      }

	      if (params.length) {
	        url += url.indexOf('?') == -1 ? "?" : "&";
	        url += params.join('&');
	      }
	      args.url = url;
	      delete args.data;
	    }
	    return args;
	  },
	  _parseFeed: function(f){
	    var feed;
	    if (!f) {
	      return 0xff;
	    } else if (f.constructor.toString().indexOf("Array") >= 0) {
	      feed = [0, 0, 0, 0, 0, 0, 0, 0];
	      f.forEach(function(pos) {
	        feed[7 - pos] = 1;
	      });
	      return parseInt(feed.join(""), 2);
	    }
	  },
	  _transModel: function(keys, obj){
	    if(!keys){return obj;}
	    var keymap = {};

	    function getHash(str) {
	      var hashCode = function(str) {
	        var hash = 0,
	          i, chr, len;
	        if (str.length == 0) return hash;
	        for (i = 0, len = str.length; i < len; i++) {
	          chr = str.charCodeAt(i);
	          hash = ((hash << 5) - hash) + chr;
	          hash |= 0; // Convert to 32bit integer
	        }
	        return hash;
	      };

	      var i = hashCode(str);
	      return "0x" + ((0xFFFF & i) ^ (i >>> 16)).toString(16);
	    }

	    function generateKeys(keys) {
	      keys.forEach(function(key) {
	        keymap[getHash(key)] = key;
	      });
	    }

	    function isArray(val) {
	      return Object.prototype.toString.call(val) == "[object Array]";
	    }

	    function isObject(val) {
	      return Object.prototype.toString.call(val) == "[object Object]";
	    }

	    function translate(obj){
	      if (isObject(obj)) {
	        delete obj.__name;
	        for (var key in obj) {
	          var val;
	          if (keymap[key]) {
	            val = obj[keymap[key]] = obj[key];
	            translate(val);
	            delete obj[key];
	          }
	        }
	      } else if (isArray(obj)) {
	        obj.forEach(function(item) {
	          translate(item);
	        });
	      }
	      return obj;
	    }

	    keys.forEach(function(key) {
	      keymap[getHash(key)] = key;
	    });

	    return translate(obj);
	  },
	  _capital: function(str){
	    return str.slice(0,1).toUpperCase() + str.slice(1);
	  },
	  subscribe : function(opt) {
	    var self = this;
	    var name = opt.action;
	    var success = opt.success;
	    var handle = opt.handle;
	    var messageName;

	    function mainHandler(e){
	      _events[name] && _events[name].length && _events[name].forEach(function(func) {
	        func && func(e);
	      });
	    }

	    function registerPageEvents(){
	      if(messageName){
	        self[messageName] = mainHandler;
	        opt.success && opt.success();
	      }
	    }

	    if (_events[name]) {
	      opt.success && opt.success();
	      _events[name].push(handle);
	    } else {
	      if(pageEvents.indexOf(name) != -1){
	        messageName = "on" + self._capital(name);
	        if(name == 'scroll'){
	          // 仅scroll事件需要toggle开关
	          this._send(messageName, {
	            success: registerPageEvents
	          });
	        }else{
	          // 不然就直接注册上了
	          registerPageEvents();
	        }
	      }else{
	        this._send("subscribe", {
	          action: name,
	          success: opt.success,
	          handle: mainHandler
	        });
	      }

	      _events[name] = [handle];
	    }
	  },

	  unsubscribe : function(opt) {
	    var name = opt.action;
	    var success = opt.success;
	    var handle = opt.handle;
	    var self = this;

	    var index = _events[name] ? _events[name].indexOf(handle) : -1;

	    function unregisterPageEvents(){
	      self[callbackName] = NOOP;
	    }

	    if (index != -1) {
	      _events[name].splice(index, 1);
	      success && success();
	      if(!_events[name].length){
	        _events[name] = null;
	      }
	    }else if(!handle){
	      _events[name] = null;
	    }

	    if(!_events[name]){
	      // unregister
	      // if is page event
	      if(pageEvents.indexOf(name) != -1 && after7_6){
	        var messageName = "off" + self._capital(name);
	        var callbackName = "on" + self._capital(name);
	        // 与安卓确认
	        if(name == 'scroll'){
	          this._send(messageName, {
	            success: unregisterPageEvents
	          });
	        }else{
	          unregisterPageEvents();
	        }
	      }else{
	        this._send("unsubscribe", {
	          action: name,
	          success: success
	        });
	      }
	    }
	    // if not found, remove all;
	  },

	  getUA: function(){},
	  /**
	   * callback function to be invoked from native
	   * @param  {Number} callbackId
	   * @param  {Object} retValue
	   */
	  callback: function(callbackId, retValue){
	    var win = window;
	    var callbackFuncName = this._generateCallbackName(callbackId);
	    var callback = window[callbackFuncName];

	    if(callback){
	      this.log("触发回调 ", "callbackId:" + callbackId);
	      setTimeout(function(){
	        callback && callback.call(self,retValue);
	      });
	      if(retValue.result == "complete" || retValue.result == "error"){
	        win[callbackFuncName] = null;
	        delete win[callbackFuncName];
	      }
	    }
	  }
	};

/***/ },
/* 17 */
/***/ function(module, exports) {

	var queue = module.exports = function(worker){
		var currentData = null;
		var currentCallback = null;
		var q = {
			timeout: null,
			running : false,
			tasks: [],
			push: function(data, cb){
				var callback = cb || function(data){}
				q.tasks.push({
					data: data,
					callback: callback
				});
				setTimeout(function(){
					q.process();
				}, 0);
			},
			dequeue: function(){
				if(currentCallback){
					currentCallback();
				}else{
					q.running = false;
				}
			},
			process: function(){
				if(q.tasks.length && !q.running){
					var task = q.tasks.shift();
					q.running = true;
					currentCallback = function(){
						q.running = false;
						task.callback(task.data);
						q.process();
					};
					currentData = task.data;
					worker(task.data, currentCallback);
				}
			}
		}
		return q;
	};

/***/ },
/* 18 */
/***/ function(module, exports) {

	module.exports = {
	  _iOSNetworkType: function (result) {
	    var networkType;
	    var types = {
	      kSCNetworkReachabilityFlagsTransientConnection: 1 << 0,
	      kSCNetworkReachabilityFlagsReachable: 1 << 1,
	      kSCNetworkReachabilityFlagsConnectionRequired: 1 << 2,
	      kSCNetworkReachabilityFlagsConnectionOnTraffic: 1 << 3,
	      kSCNetworkReachabilityFlagsInterventionRequired: 1 << 4,
	      kSCNetworkReachabilityFlagsConnectionOnDemand: 1 << 5,
	      kSCNetworkReachabilityFlagsIsLocalAddress: 1 << 16,
	      kSCNetworkReachabilityFlagsIsDirect: 1 << 17,
	      kSCNetworkReachabilityFlagsIsWWAN: 1 << 18
	    };
	    var type = +result.type;
	    var subType = result.subType;
	    var returnValue;
	    // 2g, 3g, 4g
	    function getMobileType(subType) {
	      switch (subType) {
	        case "CTRadioAccessTechnologyGPRS":
	        case "CTRadioAccessTechnologyEdge":
	        case "CTRadioAccessTechnologyCDMA1x":
	          return "2g";
	        case "CTRadioAccessTechnologyLTE":
	          return "4g";
	        case "CTRadioAccessTechnologyWCDMA":
	        case "CTRadioAccessTechnologyHSDPA":
	        case "CTRadioAccessTechnologyHSUPA":
	        case "CTRadioAccessTechnologyCDMA1x":
	        case "CTRadioAccessTechnologyCDMAEVDORev0":
	        case "CTRadioAccessTechnologyCDMAEVDORevA":
	        case "CTRadioAccessTechnologyCDMAEVDORevB":
	        case "CTRadioAccessTechnologyeHRPD":
	          return "3g";
	      }
	    }

	    if ((type & types.kSCNetworkReachabilityFlagsReachable) == 0) {
	      return "none";
	    }

	    if ((type & types.kSCNetworkReachabilityFlagsConnectionRequired) == 0) {
	      // if target host is reachable and no connection is required
	      //  then we'll assume (for now) that your on Wi-Fi
	      returnValue = "wifi";
	    }


	    if (
	      (type & types.kSCNetworkReachabilityFlagsConnectionOnDemand) != 0
	      ||
	      (type & types.kSCNetworkReachabilityFlagsConnectionOnTraffic) != 0
	    ) {
	      // ... and the connection is on-demand (or on-traffic) if the
	      //     calling application is using the CFSocketStream or higher APIs
	      if ((type & types.kSCNetworkReachabilityFlagsInterventionRequired) == 0) {
	        // ... and no [user] intervention is needed
	        returnValue = "wifi";
	      }
	    }

	    if ((type & types.kSCNetworkReachabilityFlagsIsWWAN) == types.kSCNetworkReachabilityFlagsIsWWAN) {
	      // ... but WWAN connections are OK if the calling application
	      //     is using the CFNetwork (CFSocketStream?) APIs.
	      returnValue = getMobileType(subType);
	    }

	    return returnValue;
	  },
	  _androidNetworkType: function (result) {
	    var type = result.type;
	    var subType = result.subType;

	    if (type == 0) {
	      switch (subType) {
	        case 1:
	        case 2:
	        case 4:
	        case 7:
	        case 11:
	          return "2g";
	        case 3:
	        case 5:
	        case 6:
	        case 8:
	        case 9:
	        case 10:
	        case 12:
	        case 14:
	        case 15:
	          return "3g";
	        case 13:
	          return "4g";
	      }
	    }

	    if (type == 1) {
	      return "wifi";
	    } else {
	      return "none";
	    }
	  },
	  getNetworkType : function(opt) {
	    var self = this;
	    var _success = opt.success;

	    this._send("getNetworkType", {
	      success: function(result) {
	        var ua = self._osUA;
	        var networkType;

	        switch (ua.name) {
	          case "iphone":
	            networkType = this._iOSNetworkType(result);
	            break;
	          case "android":
	            networkType = this._androidNetworkType(result);
	            break;
	        }

	        _success && _success({
	          networkType: networkType,
	          raw: {
	            type: result.type,
	            subType: result.subType
	          }
	        });
	      },
	      fail: opt.fail
	    });
	  }
	}

/***/ },
/* 19 */
/***/ function(module, exports) {

	module.exports = function () {
	    var output = {};
	    Array.prototype.forEach.call(arguments, function (object) {
	        for (var key in object) {
	            if (object.hasOwnProperty(key)) {
	                output[key] = object[key];
	            }
	        }
	    });
	    return output;
	};

/***/ },
/* 20 */
/***/ function(module, exports) {

	'use strict';

	var regexVer = /dp\/com\.dianping\.[\w\.]+\/([\d\.]+)/;

	var getAppVersion = function (ua) {
	  var version;
	  var regexMAPI = /MApi/;
	  var match  = ua.match(regexVer);
	  if (match) {
	    version = match[1];
	  }else if (regexMAPI.test(ua)) {
	    version = '7.0.0';
	  }else{
	    version = 'web';
	  }
	  return version;
	};
	var getOSName = function (ua) {
	  var regexAndroid = /android/i;
	  var regexIos = /ipad|iphone/i;
	  if (regexAndroid.test(ua)) {
	    return 'android';
	  }else if (regexIos.test(ua)) {
	    return 'ios';
	  }
	};

	var getAdapterVersion = function (ua) {
	  if (ua.match(regexVer)) {
	    var reg = /adapter\/([\d\.]+)/;
	    var match = ua.match(reg);
	    if (match) {
	      return match[1];
	    }
	  }
	};

	var getWebviewVersion = function(ua) {
	  return getAdapterVersion(ua) || getAppVersion(ua);
	};

	var appVersion = getAppVersion(navigator.userAgent);
	var osName = getOSName(navigator.userAgent);

	module.exports = {
	  appVersion: appVersion,
	  getAppVersion: getAppVersion,
	  osName: osName,
	  getOSName: getOSName,
	  getWebviewVersion: getWebviewVersion,
	  actionMapping: function (method) {
	    return function (opt) {
	      this._send(method, opt);
	    };
	  }
	};

/***/ },
/* 21 */
/***/ function(module, exports) {

	module.exports = [
	  /*
	  * Common
	  */
	  "getRequestId", 
	  "isInstalledApp",
	  /*
	  * DeviceInfo
	  */
	  "getNetworkType", 
	  "getVersion",
	  /*
	  * UserInfos
	  */
	  "getUserInfo", 
	  "login", 
	  "updateAccount", 
	  "logout",
	  "thirdLogin",
	  /*
	  * GeoInfos
	  */ 
	  "getCityId", 
	  "getLocation", 
	  "getCity",
	  /*
	  * Common business
	  */
	  "setPullDown", 
	  "stopPullDown", 
	  "openScheme", 
	  "jumpToScheme", 
	  "closeWindow", 
	  "getContactList", 
	  "sendSMS", 
	  "bindPhone",
	  "ajax", 
	  "setSpotlight",
	  "getHealthData",
	  /*
	  * Storage
	  */
	  "store", 
	  "retrieve",
	  /*
	  *  Picture
	  */
	  "downloadImage", 
	  "chooseImage", 
	  "previewImage",
	  /*
	  * Audio
	  */
	  "playVoice",
	  /*
	  * Share
	  */
	  "share",
	  /*
	  * Broadcast
	  */
	  "publish", 
	  "subscribe", 
	  "unsubscribe", 

	  /*
	  * System widget
	  */
	  "alert", 
	  "prompt", 
	  "confirm", 
	  "actionSheet", 
	  /*
	  * System UI
	  */
	  "setTitle", 
	  "setBackgroundColor", 
	  "setNavigationBarHidden", 
	  "setScrollEnabled",
	  "setLLButton", 
	  "setLRButton", 
	  "setRLButton", 
	  "setRRButton", 
	  "setBouncesEnabled",
	  "setStatusBarStyle",
	  /*
	  * Private
	  */
	  "getCX",
	  "pay"
	];

/***/ },
/* 22 */
/***/ function(module, exports) {

	'use strict';

	var _err = window.onerror;
	var url = 'http://114.80.165.63/broker-service/api/js';
	window.onerror = function(err, file, line, col, error){
	  var e = encodeURIComponent;
	  var time = Date.now();
	  (new window.Image).src = url
	    + '?error=' + e(err)
	    + '&v=1'
	    + '&data=' + e(error && error.stack ? error.stack : '')
	    + '&url=' + e(location.href)
	    + '&file=' + e(file)
	    + '&line=' + e(line)
	    + '&col=' + e(col)
	    + '&timestamp=' + time;
	  _err && _err(err, file, line, col, error);
	};

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var util = __webpack_require__(20);

	module.exports = {
	  appVersion: '7.0',
	  _parseFeed: function(f){
	    var feed;
	    if (!f) {
	      return 0xff;
	    } else if (f.constructor.toString().indexOf('Array') >= 0) {
	      feed = [0, 0, 0, 0, 0, 0, 0, 0];
	      f.forEach(function(pos) {
	        feed[pos] = 1;
	      });
	      return parseInt(feed.join(''), 2);
	    }
	  },
	  share : function(opts){
	    opts.feed = this._parseFeed(opts.feed);
	    opts.url = this._tidyUrlParams(opts.url);
	    this._sendMessage('share', opts);
	  },
	  initShare: function(opt){
	    var success = opt.success;
	    var fail = opt.fail;
	    var src = 'dpshare://_?content=';
	    src += encodeURIComponent(JSON.stringify({
	      title: opt.title,
	      desc: opt.desc,
	      image: opt.image,
	      feed: this._parseFeed(opt.feed),
	      url: opt.url
	    }));
	    this.shareCallback = function(result){
	      if(result.status == 'success'){
	        success && success(result);
	      }else{
	        fail && fail(result);
	      }
	    };
	    this._createIframe(src);
	  },
	  getUA: function(opt) {
	    var success = opt && opt.success;
	    var appVersion = navigator.userAgent.match(/MApi\s[\w\.]+\s\([\w\.\d]+\s([\d\.]+)/)[1];
	    var ua = {
	      platform: 'dpapp',
	      appName: 'dianping',
	      appVersion: appVersion,
	      osName: this._osUA.name,
	      osVersion: this._osUA.version
	    };
	    success && success(ua);
	    return ua;
	  },
	  ready: function(callback) {
	    this._isReady = true;
	    callback();
	  },
	  pay: function(args) {
	    var self = this;
	    var payType = args.payType;
	    var success = args.success;
	    var fail = args.fail;
	    var cx = args.cx;

	    function payOrder(data, callback) {
	      DPApp.ajax({
	        url: 'http://api.p.dianping.com/payorder.pay',
	        data: data,
	        keys: ['Content'],
	        success: function(paymsg) {
	          callback(null, paymsg);
	        },
	        fail: function() {
	          callback('fail payorder');
	        }
	      });
	    }

	    function getPaymentTool(payType) {
	      var PAY_TYPE_MINIALIPAY = 1;
	      var PAY_TYPE_WEIXINPAY = 7;
	      var PAYMENTTOOL_ALIPAY = '5:1:null#219#0';
	      var PAYMENTTOOL_WEIXINPAY = '11:1:null#217#0';
	      if (payType == PAY_TYPE_WEIXINPAY) {
	        paymentTool = PAYMENTTOOL_WEIXINPAY;
	      } else {
	        paymentTool = PAYMENTTOOL_ALIPAY;
	      }
	      return paymentTool;
	    }

	    payOrder({
	      token: args.token,
	      orderid: args.orderId,
	      paymenttool: getPaymentTool(payType),
	      cx: cx
	    }, function(err, paymsg) {
	      if (err) {
	        return fail && fail(err);
	      }

	      self._sendMessage('pay', {
	        paytype: payType,
	        paycontent: paymsg.Content
	      }, function(data) {
	        if (data.payresult) {
	          success && success(data);
	        } else {
	          fail && fail(data);
	        }
	      });
	    });
	  },
	  uploadImage: function(opts) {
	    var fail = opts.fail;
	    var handle = opts.handle;

	    this._sendMessage('uploadImage', opts, function(result) {
	      var status = result.status;
	      if (status == 'fail') {
	        fail && fail(result);
	        return;
	      } else {
	        handle && handle(result);
	      }
	    });
	  },
	  ajax: function(args) {
	    args = this._sanitizeAjaxOpts(args);
	    var _success = args.success;
	    args.success = function(e) {
	      var result = JSON.parse(e.mapiResult);
	      result = this._transModel(args.keys, result);
	      _success(result);
	    };

	    this._send('mapi', args);
	  },
	  getCX: util.actionMapping('getCX'),
	  getContactList: util.actionMapping('getContactList'),
	  getRequestId: util.actionMapping('getRequestId'),
	  closeWindow: util.actionMapping('close_web'),
	  getUserInfo: util.actionMapping('getUserInfo'),
	  getCity: util.actionMapping('getCityId'),
	  getCityId: util.actionMapping('getCityId'),
	  getLocation: util.actionMapping('getLocation')
	};

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var util = __webpack_require__(20);
	var core = __webpack_require__(1);
	var patch7  = __webpack_require__(23);

	//更新的API: share, initShare, closeWindow, _parseFeed
	//新增的API: setTitle等
	var newAPIs = [
	    'setLLButton', 
	    'setLRButton', 
	    'setRLButton', 
	    'setRRButton',
	    'setTitle',
	    'sendSMS',
	    'publish',
	    'closeWindow'
	  ];

	var _events = {};
	var pageEvents = ['appear', 'disappear', 'scroll'];
	function getPageMethodName(name) {
	  var result = 'on' + core._captal(name);
	  // fix for android 7.6.0
	  if (util.osName == 'android' && util.appVersion == '7.6.0' && /appear|disappear/.test(name)) {
	    result = name;
	  }
	  return result;
	}

	var getUA = (function() {
	  var uastr = navigator.userAgent;
	  var appVersionMatch = uastr.match(/dp\/[\w\.\d]+\/([\d\.]+)/);
	  var appVersion = appVersionMatch && appVersionMatch[1];
	  var matchPackageId = uastr.match(/dp\/(com\.dianping\.\w+)/);
	  var packageId = matchPackageId && matchPackageId[1];
	  var adapterMatch = uastr.match(/adapter\/([\d\.]+)/);
	  var adapterVersion = adapterMatch && adapterMatch[1];

	  return function(opt) {
	    var success = opt && opt.success;
	    var ua = {
	      platform: 'dpapp',
	      appName: 'dianping',
	      packageId: packageId,
	      appVersion: appVersion,
	      osName: core._osUA.name,
	      osVersion: core._osUA.version,
	      adapterVersion: adapterVersion
	    };
	    success && success(ua);
	    return ua;
	  };
	})();

	var Patch = module.exports = {
	  appVersion: '7.1.0',
	  pay: patch7.pay,
	  
	  uploadImage: patch7.uploadImage,
	  
	  getUA: getUA,

	  ready: function(callback) {
	    var self = this;
	    this._send('ready', {
	      success: function() {
	        self._isReady = true;
	        callback();
	      }
	    });
	  },

	  login: function(opt) {
	    var self = this;
	    var loginUser;

	    function getUser(callback) {
	      self.getUserInfo({
	        success: callback
	      });
	    }
	    getUser(function(result) {
	      if (result.token) {
	        opt.success && opt.success(result);
	      } else {
	        var loginEvent = 'loginSuccess';
	        var appearEvent = 'appear';

	        var loginSuccessHandler = function() {
	          getUser(function (user) {
	            loginUser = user;
	          });
	          self.unsubscribe({
	            action: loginEvent,
	            handle: loginSuccessHandler
	          });
	        };

	        self.subscribe({
	          action: loginEvent,
	          handle: loginSuccessHandler
	        });

	        var appearHandler = function () {
	          getUser(function (user) {
	            if (user && user.token) {
	              opt.success && opt.success(user);
	            }else{
	              opt.fail && opt.fail();
	            }
	            
	          });
	          self.unsubscribe({
	            action: appearEvent,
	            handle: appearHandler
	          });
	        };

	        self.subscribe({
	          action: appearEvent,
	          handle: appearHandler
	        }); 

	        self.openScheme({
	          url: 'dianping://login'
	        });
	      }
	    });
	  },
	  updateAccount: function(opt) {
	    opt = opt || {};
	    var self = this;
	    var dper = document.cookie.match(/dper=\w+/);
	    if (dper) {
	      dper = dper[0].split('=')[1];
	    }

	    if (opt.dper) {
	      dper = opt.dper;
	    }

	    if (!dper) {
	      return opt.fail && opt.fail('Missing dper');
	    }
	    var _loopGetUserInfo = function(success, fail) {
	      var retries = 0;
	      function loopGetUserInfo() {
	        self.getUserInfo({
	          success: function(info) {
	            if (info.token) {
	              success && success(info);
	            } else {
	              if (retries > 5) {
	                fail && fail();
	              } else {
	                retries++;
	                setTimeout(function() {
	                  loopGetUserInfo();
	                }, 100);
	              }
	            }
	          }
	        });
	      }
	      loopGetUserInfo();
	    };

	    self.ajax({
	      url: 'http://m.api.dianping.com/mlogin/convertdper.api',
	      data: {
	        dper: dper
	      },
	      keys: ['Token', 'NewToken'],
	      success: function(result) {
	        var ua = self.getUA();
	        if (self.Semver.gte(ua.appVersion, '7.5.0')) {
	          self._send('updateAccount', {
	            token: result.Token,
	            newtoken: result.NewToken,
	            success: function() {
	              self.getUserInfo({
	                success: opt.success
	              });
	            },
	            fail: opt.fail
	          });
	        } else {
	          self._send('loginsuccess', {
	            token: result.Token,
	            newtoken: result.NewToken
	          });

	          _loopGetUserInfo(opt.success, opt.fail);
	        }
	      },
	      fail: opt.fail
	    });
	  },
	  _parseFeed: function(f){
	    var feed;
	    if (!f) {
	      return 0xff;
	    } else if (f.constructor.toString().indexOf('Array') >= 0) {
	      feed = [0, 0, 0, 0, 0, 0, 0, 0];
	      f.forEach(function(pos) {
	        feed[7 - pos] = 1;
	      });
	      return parseInt(feed.join(''), 2);
	    }
	  },
	  share: function(opt) {
	    opt.feed = this._parseFeed(opt.feed);
	    opt.url = this._tidyUrlParams(opt.url);
	    this._send('share', opt);
	  },
	  initShare: function(opt) {
	    var self = this;
	    this.setRRButton({
	      icon: 'H5_Share',
	      handle: function() {
	        opt.handle && opt.handle();
	        self.share({
	          title: opt.title,
	          desc: opt.desc,
	          content: opt.content,
	          image: opt.image,
	          feed: opt.feed,
	          url: opt.url,
	          success: opt.success,
	          fail: opt.fail
	        });
	      }
	    });
	  },
	  subscribe: function(opt) {
	    var name = opt.action;
	    var handle = opt.handle;

	    function mainHandler(e) {
	      _events[name] && _events[name].length && _events[name].forEach(function(func) {
	        func && func(e);
	      });
	    }

	    if (_events[name]) {
	      opt.success && opt.success();
	      _events[name].push(handle);
	    } else {
	      this._send('subscribe', {
	        action: name,
	        success: opt.success,
	        handle: mainHandler
	      });

	      _events[name] = [handle];
	    }
	  },

	  unsubscribe: function(opt) {
	    var name = opt.action;
	    var success = opt.success;
	    var handle = opt.handle;

	    var index = _events[name] ? _events[name].indexOf(handle) : -1;

	    if (index != -1) {
	      _events[name].splice(index, 1);
	      success && success();
	      if (!_events[name].length) {
	        _events[name] = null;
	      }
	    } else if (!handle) {
	      _events[name] = null;
	    }

	    if (!_events[name]) {
	      this._send('unsubscribe', {
	        action: name,
	        success: success
	      });
	    }
	  },

	  openScheme: function(opt) {
	    var url = opt.url;
	    var extra = opt.extra;
	    if (extra) {
	      url += '?' + this._convertUrlParams(extra);
	      delete opt.extra;
	      opt.url = url;
	    }
	    this._send('openScheme', opt);
	  }
	};

	newAPIs.forEach(function (api) {
	  Patch[api] = util.actionMapping(api);
	});

	pageEvents.forEach(function(name) {
	  Patch[getPageMethodName(name)] = function (){};
	});

/***/ },
/* 25 */
/***/ function(module, exports) {

	'use strict';

	module.exports = {
	  appVersion: '7.2.0',

	  jumpToScheme: function(opt) {
	    var url = opt.url;
	    var extra = opt.extra;
	    if (extra) {
	      url += '?' + this._convertUrlParams(extra);
	      delete opt.extra;
	      opt.url = url;
	    }
	    opt.toHome = !!opt.toHome ? 1 : 0;
	    this._send('jumpToScheme', opt);
	  },
	  publish: function(opt) {
	    var bizname = this._getBizName(opt);
	    var CONSTS = ['phoneChanged', 'AccountBindChange'];
	    if (bizname) {
	      if (CONSTS.indexOf(opt.action) == -1) {
	        opt.action = bizname + ':' + opt.action;
	      }
	      this._send('publish', opt);
	    }
	  }
	};

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var util = __webpack_require__(20);

	module.exports = {
	  appVersion: '7.5.0',
	  
	  store: function(opt) {
	    var bizname = this._getBizName(opt);
	    if (bizname) {
	      opt.key = bizname + ':' + opt.key;
	      this._send('store', opt);
	    }
	  },
	  retrieve: function(opt) {
	    var bizname = this._getBizName(opt);
	    if (opt.key.indexOf(':') === -1) {
	      opt.key = bizname + ':' + opt.key;
	    }
	    this._send('retrieve', opt);
	  },
	  setBackgroundColor: util.actionMapping('setBackgroundColor')
	};

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var util = __webpack_require__(20);
	var core = __webpack_require__(1);

	var _events = {};
	var pageEvents = ['appear', 'disappear', 'scroll'];
	function getPageMethodName(name) {
	  var result = 'on' + core._captal(name);
	  // fix for android 7.6.0
	  if (util.osName == 'android' && util.appVersion == '7.6.0' && /appear|disappear/.test(name)) {
	    result = name;
	  }
	  return result;
	}

	module.exports = {
	  appVersion: '7.6.0',
	  
	  isInstalledApp: util.actionMapping('isInstalledApp'),

	  subscribe: function(opt) {
	    var self = this;
	    var name = opt.action;
	    var handle = opt.handle;
	    var messageName;

	    function mainHandler(e) {
	      _events[name] && _events[name].length && _events[name].forEach(function(func) {
	        func && func(e);
	      });
	    }

	    function registerPageEvents() {
	      if (messageName) {
	        window.DPApp && (window.DPApp[getPageMethodName(name)] = mainHandler);
	        opt.success && opt.success();
	      }
	    }

	    if (_events[name]) {
	      opt.success && opt.success();
	      _events[name].push(handle);
	    } else {
	      if (pageEvents.indexOf(name) !== -1) {
	        messageName = 'on' + self._captal(name);
	        if (name == 'scroll') {
	          // 仅scroll事件需要toggle开关
	          this._send(messageName, {
	            success: registerPageEvents
	          });
	        } else {
	          // 不然就直接注册上了
	          registerPageEvents();
	        }
	      } else {
	        this._send('subscribe', {
	          action: name,
	          success: opt.success,
	          handle: mainHandler
	        });
	      }

	      _events[name] = [handle];
	    }
	  },

	  unsubscribe: function(opt) {
	    var name = opt.action;
	    var success = opt.success;
	    var handle = opt.handle;
	    var self = this;

	    var index = _events[name] ? _events[name].indexOf(handle) : -1;

	    function unregisterPageEvents() {
	      self[callbackName] = function () {};
	    }

	    if (index != -1) {
	      _events[name].splice(index, 1);
	      success && success();
	      if (!_events[name].length) {
	        _events[name] = null;
	      }
	    } else if (!handle) {
	      _events[name] = null;
	    }

	    if (!_events[name]) {
	      // unregister
	      // if is page event
	      if (pageEvents.indexOf(name) !== -1) {
	        var messageName = 'off' + self._captal(name);
	        var callbackName = 'on' + self._captal(name);
	        // 与安卓确认
	        if (name == 'scroll') {
	          this._send(messageName, {
	            success: unregisterPageEvents
	          });
	        } else {
	          unregisterPageEvents();
	        }
	      } else {
	        this._send('unsubscribe', {
	          action: name,
	          success: success
	        });
	      }
	    }
	  },
	};

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var util = __webpack_require__(20);

	var apis = ['alert', 'confirm', 'actionSheet', 'prompt', 'setPullDown', 'stopPullDown', 'downloadImage'];
	var core = {
	  appVersion: '7.8.0'
	};

	apis.forEach(function (api) {
	  var fn = util.actionMapping(api);
	  core[api] = fn;
	});
	core.prompt = function(opt) {
	  if (!opt.placeholder) {
	    opt.placeholder = '';
	  }
	  this._send('prompt', opt);
	};

	module.exports = core;

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var util = __webpack_require__(20);
	var async = __webpack_require__(30);
	var core = __webpack_require__(1);

	module.exports = {
	  appVersion: '7.9.1',
	  
	  setNavigationBarHidden: util.actionMapping('setNavigationBarHidden'),

	  chooseImage: function(opt) {
	    opt = opt || {};
	    opt.count = (!opt.count || opt.count > 9 || opt.count < 1) ? 9 : opt.count;
	    this._send('chooseImage', opt);
	  },
	  uploadImage: function(opts) {
	    var success = opts.success;
	    var fail = opts.fail;
	    var handle = opts.handle;
	    var ua = this.getUA();
	    var self = this;
	    if (opts.localId || opts.localIds) {
	      if (core.Semver.gte(ua.adapterVersion || ua.appVersion, '7.9.1')) {
	        if (opts.localIds) {
	          (function(ids) {
	            var picKeys = {};
	            var photoInfos = [];
	            async.mapSeries(ids, function(id, done){
	              self._send('uploadPhoto', {
	                localId: id,
	                success: function(e){
	                  picKeys[id] = e.picKey;
	                  photoInfos.push({
	                    localId: id,
	                    picKey: e.picKey//FIX BUG, What 'picKey' mean?
	                  });
	                  done(null);
	                },
	                fail: function(e){
	                  done(e);
	                }
	              });
	            }, function(e){
	              if(e){
	                fail && fail(e);
	              }else{
	                success && success({
	                  picKeys: picKeys,
	                  photoInfos: photoInfos
	                });
	              }
	            });
	          })(opts.localIds);
	        } else {
	          this._send('uploadPhoto', opts);
	        }
	      } else {
	        fail({
	          errMsg: 'ERR_NOT_IMPLEMENTED'
	        });
	      }
	    } else {
	      this._sendMessage('uploadImage', opts, function(result) {
	        var status = result.status;
	        if (status == 'fail') {
	          fail && fail(result);
	          return;
	        } else {
	          handle && handle(result);
	        }
	      });
	    }
	  },
	};

/***/ },
/* 30 */
/***/ function(module, exports) {

	'use strict';

	exports.mapSeries = function(items, process, callback) {
	    var count = items.length;
	    var current = 0;
	    var results = [];

	    function done(err, result) {
	        if (err) {
	            return callback(err);
	        }

	        current++;
	        results.push(result);
	        if(current !== count){
	            process(items[current], done);
	        }else{
	            callback(null, results);
	        }
	    }

	    process(items[current], done);
	};

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var util = __webpack_require__(20);

	module.exports = {
	  appVersion: '7.9.2',
	  
	  previewImage: util.actionMapping('previewImage')
	};

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var util = __webpack_require__(20);

	module.exports = {
	  appVersion: '7.9.4',
	  setSpotlight: function (opt) {
	    if (!opt.webpageURL) {
	      return;
	    }
	    if (!opt.scheme) {
	      opt.scheme = 'dianping://web?url=' + encodeURIComponent(opt.webpageURL);
	    }
	    this._send('setSpotlight', opt);
	  },
	  playVoice: util.actionMapping('playVoice')
	};

/***/ },
/* 33 */
/***/ function(module, exports) {

	'use strict';

	module.exports = {
	  appVersion: '7.9.6',

	  logout: function (opt) {
	    var url;
	    if (opt.type === 1) {
	      url = 'dianping://me';
	    }else if (opt.type === 2) {
	      url = 'dianping://home';
	    }
	    if (url) {
	      opt.success = function () {
	        this.openScheme({
	          url: url
	        });
	      };      
	    }
	    this._send('logout', opt);
	  }
	};

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var util = __webpack_require__(20);

	module.exports = {
	  appVersion: '8.0.0',

	  setScrollEnabled: util.actionMapping('setScrollEnabled'),
	  setBouncesEnabled: util.actionMapping('setBouncesEnabled'),

	  bindPhone: util.actionMapping('bindPhone'),
	  pay: util.actionMapping('pay')
	};

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var util = __webpack_require__(20);

	var core = {
	  appVersion: '8.0.4',
	  thirdLogin: function(opt) {
	    var type = opt.type;
	    var url;
	    switch (type){
	      case 1:
	        url = 'http://m.dianping.com/auth/app?ft=15&sso=true';
	        break;
	      case 2:
	        url = 'http://m.dianping.com/auth/app?ft=6&sso=true&redir=';
	        break;
	      case 3:
	        url = 'http://m.dianping.com/auth/app?ft=5&ssp=true&redir=';
	        break;
	      case 4:
	        url = 'http://m.dianping.com/auth/app?ft=2&source=1&sso=true&redir=';
	        break;
	    }
	    this.openScheme({
	      url: 'dianping://loginweb?url=' + encodeURIComponent(url) + '&isFromNative=true',
	    });
	  },
	  getCX: function(opt) {
	    var success = opt.success;
	    opt.success = function(res) {
	      if (res.fingerprint) {
	        res.cx = res.fingerprint;
	      }
	      success(res);
	    }
	    this._send('getCX', opt);
	  },
	  uploadImage: function(opts) {
	    var success = opts.success;
	    var fail = opts.fail;
	    var handle = opts.handle;

	    if (opts.localId || opts.localIds) {

	      //兼容业务对localId单图上传的支持
	      if (opts.localId) {
	        opts.localIds = [opts.localId];
	        delete opts.localId;
	      }
	      
	      opts.success = function(res) {
	        var obj = {};
	        var _localId;
	        if (res.ret) {
	          res.ret.forEach(function(picItem, index) {
	            _localId = picItem.localId || opts.localIds[index];
	            obj[_localId] = picItem.picKey;
	          });
	          res.photoInfos = res.ret;
	          delete res.ret;
	        }
	        res.picKeys = obj;
	        success(res);
	      };

	      this._send('uploadPhoto', opts); 

	    } else {
	      this._sendMessage('uploadImage', opts, function(result) {
	        var status = result.status;
	        if (status == 'fail') {
	          fail && fail(result);
	          return;
	        } else {
	          handle && handle(result);
	        }
	      });
	    }
	  }
	};
	if (util.osName === 'ios') {//getOSName()
	  core.setStatusBarStyle = function(opt) {
	    if (opt.style === undefined) {
	      opt.style = 0;
	    }
	    this._send('setStatusBarStyle', opt);
	  }
	}
	module.exports = core;

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var util = __webpack_require__(20);

	module.exports = {
	  appVersion: '8.0.6',

	  share: function(opts) {
	    //直接分享渠道计数从1开始
	    if (opts.shareType !== undefined) {
	      if (util.osName === 'android') {
	        //Android下兼容shareType从1开始计数
	        opts.shareType += 1;
	      }
	    }
	    opts.feed = this._parseFeed(opts.feed);
	    opts.url = this._tidyUrlParams(opts.url);
	    
	    this._send('share', opts);
	  }

	};

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var util = __webpack_require__(20);

	var core = {
	  appVersion: '8.1.0'
	};

	if (util.osName === 'ios') {
	  core.getHealthData = function(opts) {
	    // 目前支持的类型
	    var typeList = [1];
	    var type;
	    var start;
	    var end;
	    // 目前支持的环境
	    if (util.osName === 'ios') {
	      type = opts.quantityType;
	      start = opts.startDate;
	      end = opts.endDate;
	      // valid
	      if (~typeList.indexOf(type)) {
	        _handleDate() && this._send('getHealthData', opts);
	      }
	    }
	    function _handleDate() {
	      // 单位：秒
	      start = +new Date(start);
	      end = +new Date(end);
	      if (start < end) {
	        start = Math.round(start/1000);
	        end = Math.round(end/1000);
	        return true;
	      }
	    }
	  }
	}

	module.exports = core;

/***/ }
/******/ ]);